<!DOCTYPE html><html lang="en" class="library-layout-active"> <head><meta charset="UTF-8"><meta name="description" content="A knowledge library for the school"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/images/library_logo.png"><meta name="generator" content="Astro v5.8.0"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.CtSceO8m.js"></script><title>Geometric Thoughts with Guest Algebra | Arithmoi Library</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet"><link rel="stylesheet" href="/_astro/_slug_.DVI4I1KQ.css">
<link rel="stylesheet" href="/_astro/about.CX88X6Uy.css">
<style>.book-detail[data-astro-cid-y47snweo]{padding:20px;background-color:#fff;border-radius:8px;box-shadow:0 2px 10px #0000001a}.book-detail[data-astro-cid-y47snweo] h1[data-astro-cid-y47snweo]{margin-top:0;margin-bottom:.5rem;font-size:2rem;color:#333}.author[data-astro-cid-y47snweo]{font-style:italic;color:#555;margin-bottom:1rem}.summary[data-astro-cid-y47snweo]{margin-bottom:1.5rem;line-height:1.6}.pdf-embed-container[data-astro-cid-y47snweo]{margin-top:20px;border:1px solid #ddd;height:75vh;display:flex;flex-direction:column}.pdf-embed-container[data-astro-cid-y47snweo]>.pdf-viewer-container{flex-grow:1;min-height:0}
</style></head> <body> <nav data-astro-cid-5blmo7yk> <div class="nav-container" data-astro-cid-5blmo7yk> <div class="logo" data-astro-cid-5blmo7yk> <img src="/images/library_logo.png" alt="Arithmoi Library Logo" class="navbar-logo-img" data-astro-cid-5blmo7yk> <a href="/" data-astro-cid-5blmo7yk>Arithmoi Library</a> </div> <button class="hamburger" aria-label="Toggle menu" aria-expanded="false" data-astro-cid-5blmo7yk> <span class="hamburger-box" data-astro-cid-5blmo7yk> <span class="hamburger-inner" data-astro-cid-5blmo7yk></span> </span> </button> <ul class="nav-links" data-astro-cid-5blmo7yk> <li data-astro-cid-5blmo7yk><a href="/" data-astro-cid-5blmo7yk>Home</a></li> <li data-astro-cid-5blmo7yk><a href="/library" class="active" data-astro-cid-5blmo7yk>Library</a></li> <li data-astro-cid-5blmo7yk><a href="/about" data-astro-cid-5blmo7yk>About</a></li> <li data-astro-cid-5blmo7yk><a href="/contact" data-astro-cid-5blmo7yk>Contact</a></li> <!-- Theme toggle in mobile menu - using same style as desktop --> <li class="mobile-theme-toggle" data-astro-cid-5blmo7yk> <button id="theme-toggle-mobile" class="theme-toggle theme-toggle-mobile" aria-label="Toggle dark mode" title="Toggle dark/light mode" data-astro-cid-5blmo7yk> <span class="theme-icon light-icon" data-astro-cid-5blmo7yk>‚òÄÔ∏è</span> <span class="theme-icon dark-icon" data-astro-cid-5blmo7yk>üåô</span> </button> </li> </ul> <!-- Global Dark Mode Toggle - Desktop Only --> <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode" title="Toggle dark/light mode" data-astro-cid-5blmo7yk> <span class="theme-icon light-icon" data-astro-cid-5blmo7yk>‚òÄÔ∏è</span> <span class="theme-icon dark-icon" data-astro-cid-5blmo7yk>üåô</span> </button> </div> </nav> <script type="module">function g(){const e=document.querySelector(".hamburger"),t=document.querySelector(".nav-links");if(e&&t){e.replaceWith(e.cloneNode(!0));const n=document.querySelector(".hamburger");n.addEventListener("click",()=>{const o=n.getAttribute("aria-expanded")==="true"||!1;n.setAttribute("aria-expanded",!o),t.classList.toggle("is-active"),n.classList.toggle("is-active")})}}function a(){const e=document.getElementById("theme-toggle"),t=document.getElementById("theme-toggle-mobile"),n=localStorage.getItem("theme")||"light";m(n),e&&(e.replaceWith(e.cloneNode(!0)),document.getElementById("theme-toggle").addEventListener("click",()=>{i()})),t&&(t.replaceWith(t.cloneNode(!0)),document.getElementById("theme-toggle-mobile").addEventListener("click",()=>{i();const c=document.querySelector(".nav-links"),l=document.querySelector(".hamburger");c&&l&&(c.classList.remove("is-active"),l.classList.remove("is-active"),l.setAttribute("aria-expanded","false"))}))}function i(){const t=(document.documentElement.getAttribute("data-theme")||"light")==="light"?"dark":"light";m(t),localStorage.setItem("theme",t)}function m(e){document.documentElement.setAttribute("data-theme",e);const t=document.getElementById("theme-toggle"),n=document.getElementById("theme-toggle-mobile");t&&t.classList.toggle("dark-active",e==="dark"),n&&n.classList.toggle("dark-active",e==="dark")}g();a();document.addEventListener("astro:page-load",()=>{g(),a()});</script>  <button class="sidebar-toggle" aria-label="Toggle sidebar" aria-expanded="false"> <span class="hamburger-box"> <span class="hamburger-inner"></span> </span> </button> <div class="main-container"> <aside id="sidebar" data-astro-cid-ssfzsv2f> <h4 data-astro-cid-ssfzsv2f>Library Navigation</h4> <ul data-astro-cid-ssfzsv2f> <li data-astro-cid-ssfzsv2f><a href="/library/" class="sidebar-nav-item" data-astro-cid-ssfzsv2f>Welcome</a></li> <li class="collapsible-category" data-category-path="/library/insights/" data-astro-cid-ssfzsv2f> <div class="category-header" data-astro-cid-ssfzsv2f> <span class="dropdown-indicator" data-astro-cid-ssfzsv2f> <svg class="chevron-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" data-astro-cid-ssfzsv2f> <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" data-astro-cid-ssfzsv2f></path> </svg> </span> <a href="/library/insights/" class="category-title-link" data-astro-cid-ssfzsv2f> Insights </a> </div> <ul class="submenu" data-astro-cid-ssfzsv2f> <li data-astro-cid-ssfzsv2f> <a href="/library/insights/power-of-mathematics-and-numbers" data-astro-cid-ssfzsv2f> The Power of Mathematics and Numbers </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/insights/alchemy-of-symmetry-and-anti-symmetry" data-astro-cid-ssfzsv2f> The Alchemy of Symmetry and Anti-Symmetry </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/insights/bridge-of-thought" data-astro-cid-ssfzsv2f> The Bridge of Thought </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/insights/foundations-for-mathematical-reality" data-astro-cid-ssfzsv2f> Foundations for Mathematical Reality </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/insights/pondering-on-the-god-equation" data-astro-cid-ssfzsv2f> Pondering on the God Equation </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/insights/mystical-dance-of-symmetry-and-anti-symmetry" data-astro-cid-ssfzsv2f> The Mystical Dance of Symmetry and Anti-Symmetry </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/insights/mathematical-and-medical-alliance" data-astro-cid-ssfzsv2f> The Mathematical and Medical Alliance </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/insights/ontological-mathematics-and-eastern-philosophy" data-astro-cid-ssfzsv2f> Ontological Mathematics and Eastern Philosophy </a> </li> </ul> </li><li class="collapsible-category" data-category-path="/library/foundations/" data-astro-cid-ssfzsv2f> <div class="category-header" data-astro-cid-ssfzsv2f> <span class="dropdown-indicator" data-astro-cid-ssfzsv2f> <svg class="chevron-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" data-astro-cid-ssfzsv2f> <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" data-astro-cid-ssfzsv2f></path> </svg> </span> <a href="/library/foundations/" class="category-title-link" data-astro-cid-ssfzsv2f> Foundations </a> </div> <ul class="submenu" data-astro-cid-ssfzsv2f> <li data-astro-cid-ssfzsv2f> <a href="/library/foundations/essential-calculus-theorems" data-astro-cid-ssfzsv2f> Essential Calculus Theorems </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/foundations/real-and-complex-mathematical-analysis" data-astro-cid-ssfzsv2f> Real and Complex Mathematical Analysis </a> </li> </ul> </li><li class="collapsible-category is-expanded" data-category-path="/library/explorations/" data-astro-cid-ssfzsv2f> <div class="category-header" data-astro-cid-ssfzsv2f> <span class="dropdown-indicator" data-astro-cid-ssfzsv2f> <svg class="chevron-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" data-astro-cid-ssfzsv2f> <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" data-astro-cid-ssfzsv2f></path> </svg> </span> <a href="/library/explorations/" class="category-title-link" data-astro-cid-ssfzsv2f> Explorations </a> </div> <ul class="submenu" data-astro-cid-ssfzsv2f> <li data-astro-cid-ssfzsv2f> <a href="/library/explorations/novel-u3-group-applications" data-astro-cid-ssfzsv2f> A Novel U(3) Group and Applications </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/lie-groups-algebras" data-astro-cid-ssfzsv2f> Lie Groups and Lie Algebras </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/imaginary-derivation-e" data-astro-cid-ssfzsv2f> An Imaginary Derivation of e </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/asymptotic-light-geometry" data-astro-cid-ssfzsv2f> Asymptotic Light Geometry </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/derivation-complex-unit-sphere" data-astro-cid-ssfzsv2f> Derivation of the Complex Unit Sphere </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/geometric-thoughts-guest-algebra" data-astro-cid-ssfzsv2f> Geometric Thoughts with Guest Algebra </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/gravitational-wave-signal-processing" data-astro-cid-ssfzsv2f> Gravitational Wave Signal Processing </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/imaginary-angles-connection-between" data-astro-cid-ssfzsv2f> Imaginary Angles and the Connection Between </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/pascals-tetrahedron-combinatorics-theory" data-astro-cid-ssfzsv2f> Pascal&#39;s Tetrahedron, Combinatorics, and Theory </a> </li><li data-astro-cid-ssfzsv2f> <a href="/library/explorations/strange-attractor-lorenz-system" data-astro-cid-ssfzsv2f> The Strange Attractor of the Lorenz System </a> </li> </ul> </li><li data-astro-cid-ssfzsv2f> <a href="/library/masteries/" class="sidebar-nav-item category-title-like" data-astro-cid-ssfzsv2f> Masteries </a> </li> </ul> </aside>  <script>(function(){const currentPage = "/library/explorations/geometric-thoughts-guest-algebra/";

  document.addEventListener('DOMContentLoaded', () => {
    const categoryItems = document.querySelectorAll('.collapsible-category');

    categoryItems.forEach(item => {
      const header = item.querySelector('.category-header');
      const titleLink = item.querySelector('.category-title-link');
      // const categoryPath = item.dataset.categoryPath; // Already used by SSR for initial state

      if (header) {
        header.addEventListener('click', (event) => {
          // Determine if the click was on the title link itself or elsewhere in the header (e.g., indicator)
          const isTitleLinkClicked = titleLink && titleLink.contains(event.target);

          if (isTitleLinkClicked) {
            // Clicked directly on the category title link
            if (currentPage === titleLink.getAttribute('href')) {
              // If on the category's main page, toggle dropdown and prevent navigation
              event.preventDefault();
              item.classList.toggle('is-expanded');
            } else {
              // If on a different page, allow default navigation to the category page.
              // The page will reload, and server-side logic will set the 'is-expanded' state.
              return; // Do nothing here, let the link navigate
            }
          } else {
            // Clicked on the header but not directly on the title link (e.g., on indicator or padding)
            // Always toggle the dropdown in this case.
            item.classList.toggle('is-expanded');
          }
        });
      }
    });
  });
})();</script> <main class="content-area"> <div class="content-wrapper library-content-wrapper book-detail-active">  <article class="book-detail" data-astro-cid-y47snweo> <h1 data-astro-cid-y47snweo>Geometric Thoughts with Guest Algebra</h1> <p class="author" data-astro-cid-y47snweo>By: Jason Glowney</p> <p class="summary" data-astro-cid-y47snweo>An article on geometric thoughts with guest algebra.</p> <div class="pdf-embed-container" data-astro-cid-y47snweo> <div id="pdf-viewer-container" class="pdf-viewer-container" data-astro-cid-v6ggcyrl> <div class="canvas-wrapper" data-astro-cid-v6ggcyrl> <canvas id="pdf-canvas" data-astro-cid-v6ggcyrl></canvas> </div> <div class="pdf-controls" data-astro-cid-v6ggcyrl> <button id="prev-page" data-astro-cid-v6ggcyrl> <span class="icon" data-astro-cid-v6ggcyrl><</span> <span class="text" data-astro-cid-v6ggcyrl>Previous</span> </button> <div id="page-indicator" class="page-indicator" data-astro-cid-v6ggcyrl> <span id="page-num-display" data-astro-cid-v6ggcyrl></span>&nbsp;/&nbsp;<span id="page-count-display" data-astro-cid-v6ggcyrl></span> </div> <div id="page-navigation-group" style="display: none;" data-astro-cid-v6ggcyrl> <div id="page-input-container" class="page-input-container" data-astro-cid-v6ggcyrl> <input type="number" id="page-input" min="1" data-astro-cid-v6ggcyrl> <button id="goto-page-btn" data-astro-cid-v6ggcyrl>Go</button> <span id="page-input-error-icon" class="page-input-error-icon" style="display: none;" data-astro-cid-v6ggcyrl>&#9432;</span> </div> </div> <button id="next-page" data-astro-cid-v6ggcyrl> <span class="icon" data-astro-cid-v6ggcyrl>></span> <span class="text" data-astro-cid-v6ggcyrl>Next</span> </button> <span class="spacer" data-astro-cid-v6ggcyrl></span> <button id="zoom-out" class="zoom-button" data-astro-cid-v6ggcyrl>-</button> <span id="zoom-level" class="zoom-level-display" data-astro-cid-v6ggcyrl>100%</span> <button id="zoom-in" class="zoom-button" data-astro-cid-v6ggcyrl>+</button> <span class="spacer" data-astro-cid-v6ggcyrl></span> <button id="fullscreen-btn" data-astro-cid-v6ggcyrl> <span class="icon" data-astro-cid-v6ggcyrl>&#x2922;</span> <!-- Unicode for fullscreen icon ‚§¢ --> <span class="text" style="display: none;" data-astro-cid-v6ggcyrl>Full Screen</span> <!-- Text always hidden --> </button> <!-- NEW: Hamburger Menu Button --> <button id="menu-btn" class="menu-button" title="More Options" data-astro-cid-v6ggcyrl> <span class="icon" data-astro-cid-v6ggcyrl>‚ò∞</span> </button> </div> <!-- NEW: Modal Overlay Menu --> <div id="pdf-menu-overlay" class="pdf-menu-overlay" style="display: none;" data-astro-cid-v6ggcyrl> <div class="pdf-menu-modal" data-astro-cid-v6ggcyrl> <div class="menu-header" data-astro-cid-v6ggcyrl> <h3 class="menu-title" data-astro-cid-v6ggcyrl>üìñ PDF Viewer Options</h3> <button id="menu-close-btn" class="menu-close-btn" data-astro-cid-v6ggcyrl>&times;</button> </div> <div class="menu-content" data-astro-cid-v6ggcyrl> <div class="menu-section" data-astro-cid-v6ggcyrl> <h4 class="menu-section-title" data-astro-cid-v6ggcyrl>üìñ Reading Mode</h4> <div class="menu-options" data-astro-cid-v6ggcyrl> <label class="menu-option" data-astro-cid-v6ggcyrl> <input type="radio" name="reading-mode" value="read" checked data-astro-cid-v6ggcyrl> <span class="option-icon" data-astro-cid-v6ggcyrl>üìñ</span> <span class="option-text" data-astro-cid-v6ggcyrl>Read Only</span> </label> <label class="menu-option" data-astro-cid-v6ggcyrl> <input type="radio" name="reading-mode" value="audio" data-astro-cid-v6ggcyrl> <span class="option-icon" data-astro-cid-v6ggcyrl>üîä</span> <span class="option-text" data-astro-cid-v6ggcyrl>Audio Mode</span> </label> <!-- COMMENTED OUT - Video Mode and Picture-in-Picture options (not ready yet)
            <label class="menu-option">
              <input type="radio" name="reading-mode" value="video">
              <span class="option-icon">üì∫</span>
              <span class="option-text">Video Mode</span>
            </label>
            <label class="menu-option">
              <input type="radio" name="reading-mode" value="pip">
              <span class="option-icon">üñºÔ∏è</span>
              <span class="option-text">Picture-in-Picture</span>
            </label>
            --> </div> </div> <!-- TTS Controls Section (shown when audio modes active) --> <div id="tts-menu-section" class="menu-section" style="display: none;" data-astro-cid-v6ggcyrl> <h4 class="menu-section-title" data-astro-cid-v6ggcyrl>üéµ Audio Controls</h4> <div class="menu-controls" data-astro-cid-v6ggcyrl> <div class="control-row" data-astro-cid-v6ggcyrl> <button id="tts-play-pause" class="menu-control-btn" data-astro-cid-v6ggcyrl> <span class="icon" data-astro-cid-v6ggcyrl>‚ñ∂Ô∏è</span> <span class="text" data-astro-cid-v6ggcyrl>Play</span> </button> <button id="tts-stop" class="menu-control-btn" data-astro-cid-v6ggcyrl> <span class="icon" data-astro-cid-v6ggcyrl>‚èπÔ∏è</span> <span class="text" data-astro-cid-v6ggcyrl>Stop</span> </button> </div> <div class="control-row" data-astro-cid-v6ggcyrl> <label class="control-label" data-astro-cid-v6ggcyrl>üé§ Voice:</label> <select id="voice-selector" class="menu-select" data-astro-cid-v6ggcyrl> <option data-astro-cid-v6ggcyrl>Default Voice</option> </select> </div> <div class="control-row" data-astro-cid-v6ggcyrl> <label class="control-label" data-astro-cid-v6ggcyrl>‚ö° Speed:</label> <select id="speed-selector" class="menu-select" data-astro-cid-v6ggcyrl> <option value="0.5" data-astro-cid-v6ggcyrl>0.5x</option> <option value="0.75" data-astro-cid-v6ggcyrl>0.75x</option> <option value="1.0" selected data-astro-cid-v6ggcyrl>1.0x</option> <option value="1.25" data-astro-cid-v6ggcyrl>1.25x</option> <option value="1.5" data-astro-cid-v6ggcyrl>1.5x</option> <option value="2.0" data-astro-cid-v6ggcyrl>2.0x</option> </select> </div> <div class="control-row" data-astro-cid-v6ggcyrl> <label class="menu-option" data-astro-cid-v6ggcyrl> <input type="checkbox" id="auto-advance" data-astro-cid-v6ggcyrl> <span class="option-text" data-astro-cid-v6ggcyrl>üîÑ Auto-advance pages</span> </label> </div> </div> </div> <!-- COMMENTED OUT - Display Options section (not ready yet)
        <div class="menu-section">
          <h4 class="menu-section-title">üé® Display Options</h4>
          <div class="menu-controls">
            <div class="control-row">
              <label class="control-label">üåà Highlight:</label>
              <input type="color" id="highlight-color" value="#ffff00" class="color-picker">
            </div>
          </div>
        </div>
        --> </div> </div> </div> </div> <script>(function(){const pdfUrl = "/pdfs/explorations/glowney_jason_Geometric_Thoughts_with_Guest_Algebra_i.pdf";
const pdfjsWorkerSrc = "/pdf.worker.min.mjs";

  // Import the working Cloud TTS Manager
  import('/src/components/CloudTtsManager.js');
  // Global variables to track current PDF state
  let currentPdfDoc = null;
  let currentPageNum = 1;
  let currentScale = 1.5;
  let totalPages = 0;
  let isRendering = false;
  let renderTask = null;
  let renderQueue = [];
  let isProcessingQueue = false;

  // Global menu variables - moved to global scope to fix variable access issues
  let menuBtn, menuOverlay, menuModal, menuCloseBtn, ttsMenuSection, readingModeInputs;
  let ttsPlayPauseBtn, ttsStopBtn, voiceSelector, speedSelector;
  let autoAdvanceCheckbox, highlightColorInput;
  let menuInitialized = false;
  let lastToggleTime = 0;

  // Global TTS state variables
  let currentReadingMode = 'read';
  let ttsUtterance = null;
  let isPlaying = false;
  let currentPageText = '';
  let availableVoices = [];
  let selectedVoice = null;
  let speechRate = 1.0;
  let autoAdvance = false;
  let highlightColor = '#ffff00';

  // Cleanup function to remove existing event listeners
  function cleanupPdfViewer() {
    // Cancel any ongoing render task
    if (renderTask) {
      try {
        renderTask.cancel();
      } catch (e) {
        console.log('Render task already completed or cancelled');
      }
      renderTask = null;
    }
    
    // Clear render queue
    renderQueue = [];
    isProcessingQueue = false;
    
    // Remove click outside handler
    if (window.pdfClickOutsideHandler) {
      document.removeEventListener('click', window.pdfClickOutsideHandler, true);
      window.pdfClickOutsideHandler = null;
    }
    
    // Reset menu initialization state
    menuInitialized = false;
    if (menuBtn && menuBtn.hasAttribute('data-menu-listener')) {
      menuBtn.removeAttribute('data-menu-listener');
    }
    
    // Clear canvas
    const canvas = document.getElementById('pdf-canvas');
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }
    
    // Reset global state
    currentPdfDoc = null;
    currentPageNum = 1;
    currentScale = 1.5;
    totalPages = 0;
    isRendering = false;
    window.currentPdfUrl = null;
  }

  async function initializePdfViewer() {
    try {
      // Check if container exists
      const container = document.getElementById('pdf-viewer-container');
      if (!container) {
        console.error('PDF container not found');
        return;
      }

      // Force cleanup and reload for every initialization to ensure clean state
      console.log(`Initializing PDF viewer with URL: ${pdfUrl}`);
      console.log(`Previous URL was: ${window.currentPdfUrl}`);
      
      // Always cleanup to ensure clean state
      cleanupPdfViewer();
      
      // Set current URL immediately to prevent race conditions
      window.currentPdfUrl = pdfUrl;
      console.log('Loading PDF:', pdfUrl);

      // Dynamically import pdfjs-dist to keep initial load small
      const pdfjsLib = await import('/pdf.min.mjs');
      if (!pdfjsLib.GlobalWorkerOptions.workerSrc && pdfjsWorkerSrc) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorkerSrc;
      }

      const loadingTask = pdfjsLib.getDocument(pdfUrl);
      currentPdfDoc = await loadingTask.promise;
      totalPages = currentPdfDoc.numPages;
      
      console.log(`PDF loaded successfully: ${totalPages} pages`);

      // Get DOM elements
      const pageNumElement = document.getElementById('page-num-display');
      const pageCountElement = document.getElementById('page-count-display');
      const pageIndicator = document.getElementById('page-indicator');
      const pageNavigationGroup = document.getElementById('page-navigation-group');
      const pageInputContainer = document.getElementById('page-input-container');
      const pageInput = document.getElementById('page-input');
      const gotoPageBtn = document.getElementById('goto-page-btn');
      const pageInputErrorIcon = document.getElementById('page-input-error-icon');
      const prevButton = document.getElementById('prev-page');
      const nextButton = document.getElementById('next-page');
      const zoomOutButton = document.getElementById('zoom-out');
      const zoomInButton = document.getElementById('zoom-in');
      const zoomLevelElement = document.getElementById('zoom-level');
      const fullscreenButton = document.getElementById('fullscreen-btn');
      const pdfViewerContainer = document.getElementById('pdf-viewer-container');

      // Initialize page display with correct total pages
      if (pageCountElement) {
        pageCountElement.textContent = totalPages.toString();
        console.log(`Set page count display to: ${totalPages}`);
      } else {
        console.error('Page count element not found');
      }
      
      if (pageNumElement) {
        pageNumElement.textContent = currentPageNum.toString();
        console.log(`Set current page display to: ${currentPageNum}`);
      } else {
        console.error('Page number element not found');
      }
      
      // Set page input max value
      if (pageInput) {
        pageInput.max = totalPages.toString();
        pageInput.min = "1";
      }

      function updateZoomLevelDisplay() {
        if (zoomLevelElement) {
          zoomLevelElement.textContent = `${Math.round(currentScale * 100)}%`;
        }
      }

      // Queue-based rendering system to prevent canvas conflicts
      async function queueRender(pageNum, scale = null) {
        return new Promise((resolve, reject) => {
          const renderRequest = {
            pageNum,
            scale: scale || currentScale,
            resolve,
            reject
          };
          
          renderQueue.push(renderRequest);
          processRenderQueue();
        });
      }

      async function processRenderQueue() {
        if (isProcessingQueue || renderQueue.length === 0) {
          return;
        }
        
        isProcessingQueue = true;
        
        while (renderQueue.length > 0) {
          const request = renderQueue.shift();
          
          try {
            await renderPageInternal(request.pageNum, request.scale);
            request.resolve();
          } catch (error) {
            request.reject(error);
          }
        }
        
        isProcessingQueue = false;
      }

      async function renderPageInternal(num, scale) {
        if (!currentPdfDoc) {
          throw new Error('Cannot render page: missing PDF document');
        }
        
        if (num < 1 || num > totalPages) {
          throw new Error(`Invalid page number: ${num}. Valid range: 1-${totalPages}`);
        }
        
        // Cancel any ongoing render operation
        if (renderTask) {
          try {
            renderTask.cancel();
          } catch (e) {
            console.log('Previous render task already completed');
          }
          renderTask = null;
        }
        
        console.log(`Rendering page ${num} of ${totalPages} at scale ${scale}`);
        
        const page = await currentPdfDoc.getPage(num);
        const viewport = page.getViewport({ scale });

        // Get the canvas container
        const canvasWrapper = document.querySelector('.canvas-wrapper');
        if (!canvasWrapper) {
          throw new Error('Canvas wrapper not found');
        }

        // Always create a fresh canvas to avoid conflicts
        const oldCanvas = document.getElementById('pdf-canvas');
        if (oldCanvas) {
          oldCanvas.remove();
        }
        
        const canvas = document.createElement('canvas');
        canvas.id = 'pdf-canvas';
        
        // Set canvas dimensions to match viewport
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        // Set the CSS display size of the canvas to match its drawing resolution
        canvas.style.width = viewport.width + 'px';
        canvas.style.height = viewport.height + 'px';
        
        // Add canvas to DOM
        canvasWrapper.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        
        const renderContext = {
          canvasContext: ctx,
          viewport: viewport,
        };
        
        // Store the render task so we can cancel it if needed
        renderTask = page.render(renderContext);
        await renderTask.promise;
        renderTask = null;
        
        // Update current page number and scale
        currentPageNum = num;
        currentScale = scale;
        
        // Update page display
        const currentPageNumElement = document.getElementById('page-num-display');
        if (currentPageNumElement) {
          currentPageNumElement.textContent = num.toString();
        }

        // Update button states
        const currentPrevButton = document.getElementById('prev-page');
        const currentNextButton = document.getElementById('next-page');
        if (currentPrevButton) {
          currentPrevButton.disabled = num <= 1;
        }
        if (currentNextButton) {
          currentNextButton.disabled = num >= totalPages;
        }
        
        console.log(`Successfully rendered page ${num}`);
      }

      // Public render function that uses the queue
      async function renderPage(num, scale = null) {
        try {
          await queueRender(num, scale);
        } catch (error) {
          if (error.name === 'RenderingCancelledException') {
            console.log('Render operation was cancelled');
          } else {
            console.error('Error rendering PDF page:', error);
            const container = document.getElementById('pdf-viewer-container');
            if (container) {
              const canvasWrapper = container.querySelector('.canvas-wrapper');
              if (canvasWrapper) {
                canvasWrapper.innerHTML = `<p>Error rendering page ${num}: ${error.message}</p>`;
              }
            }
          }
        }
      }

      // Add event listeners with null checks
      if (prevButton) {
        prevButton.addEventListener('click', async () => {
          if (currentPageNum <= 1) return;
          await renderPage(currentPageNum - 1);
        });
      }

      if (nextButton) {
        nextButton.addEventListener('click', async () => {
          if (currentPageNum >= totalPages) return;
          await renderPage(currentPageNum + 1);
        });
      }

      // Initial render
      await renderPage(currentPageNum);
      updateZoomLevelDisplay();

      if (zoomInButton) {
        zoomInButton.addEventListener('click', async () => {
          const newScale = currentScale + 0.25;
          await renderPage(currentPageNum, newScale);
          updateZoomLevelDisplay();
        });
      }

      if (zoomOutButton) {
        zoomOutButton.addEventListener('click', async () => {
          if (currentScale <= 0.25) return; // Minimum scale
          const newScale = currentScale - 0.25;
          await renderPage(currentPageNum, newScale);
          updateZoomLevelDisplay();
        });
      }

      if (fullscreenButton && pdfViewerContainer) {
        fullscreenButton.addEventListener('click', () => {
          try {
            if (!document.fullscreenElement &&
                !document.webkitFullscreenElement &&
                !document.mozFullScreenElement &&
                !document.msFullscreenElement) {
              
              // Check if fullscreen is supported
              if (!document.fullscreenEnabled &&
                  !document.webkitFullscreenEnabled &&
                  !document.mozFullScreenEnabled &&
                  !document.msFullscreenEnabled) {
                console.log('Fullscreen is not supported or allowed in this browser');
                return;
              }
              
              // Try different fullscreen methods for browser compatibility
              if (pdfViewerContainer.requestFullscreen) {
                pdfViewerContainer.requestFullscreen().catch(err => {
                  console.log('Fullscreen request failed:', err.name, err.message);
                });
              } else if (pdfViewerContainer.webkitRequestFullscreen) {
                pdfViewerContainer.webkitRequestFullscreen();
              } else if (pdfViewerContainer.mozRequestFullScreen) {
                pdfViewerContainer.mozRequestFullScreen();
              } else if (pdfViewerContainer.msRequestFullscreen) {
                pdfViewerContainer.msRequestFullscreen();
              } else {
                console.log('No fullscreen method available');
              }
            } else {
              // Exit fullscreen
              if (document.exitFullscreen) {
                document.exitFullscreen().catch(err => {
                  console.log('Exit fullscreen failed:', err.name, err.message);
                });
              } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
              } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
              } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
              }
            }
          } catch (err) {
            console.error('Fullscreen error:', err);
            // Don't show alerts for fullscreen errors - just log them
          }
        });
      }

    // Listen for fullscreen changes to update button text/icon if needed
    const fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
    
    fullscreenEvents.forEach(eventName => {
      document.addEventListener(eventName, () => {
        // For now, we don't change the button appearance based on state,
        // but this is where you could do it.
        // For example, change "Full Screen" to "Exit Full Screen"
        const isFullscreen = !!(document.fullscreenElement ||
                                document.webkitFullscreenElement ||
                                document.mozFullScreenElement ||
                                document.msFullscreenElement);
        console.log('Fullscreen state changed:', isFullscreen);
      });
    });

      // --- Go to Page Functionality ---
      function switchToPageDisplayView() {
        if (pageNavigationGroup) {
          pageNavigationGroup.style.display = 'none';
        }
        if (pageInput) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
        }
        if (pageInputErrorIcon) {
          pageInputErrorIcon.style.display = 'none';
          pageInputErrorIcon.removeAttribute('title');
        }
        if (pageIndicator) {
          pageIndicator.style.display = 'inline-flex';
        }
      }

      function switchToPageInputView() {
        if (pageIndicator) {
          pageIndicator.style.display = 'none';
        }
        if (pageNavigationGroup) {
          pageNavigationGroup.style.display = 'block';
        }
        if (pageInput) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
          pageInput.value = currentPageNum.toString();
          pageInput.max = totalPages.toString();
          pageInput.focus();
          pageInput.select();
        }
        if (pageInputErrorIcon) {
          pageInputErrorIcon.style.display = 'none';
          pageInputErrorIcon.removeAttribute('title');
        }
      }

      if (pageIndicator) {
        pageIndicator.addEventListener('click', switchToPageInputView);
      }

      async function handleGoToPage() {
        if (!pageInput) return;
        const newPageNum = parseInt(pageInput.value, 10);
        if (!isNaN(newPageNum) && newPageNum >= 1 && newPageNum <= totalPages) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
          if (pageInputErrorIcon) {
            pageInputErrorIcon.style.display = 'none';
            pageInputErrorIcon.removeAttribute('title');
          }
          if (newPageNum !== currentPageNum) {
            await renderPage(newPageNum);
          }
          switchToPageDisplayView();
        } else {
          pageInput.classList.add('input-error');
          pageInput.setAttribute('aria-invalid', 'true');
          if (pageInputErrorIcon) {
            pageInputErrorIcon.style.display = 'inline';
            pageInputErrorIcon.title = `Choose a page number between 1 and ${totalPages}.`;
          }
          pageInput.focus();
          pageInput.select();
        }
      }

      if (gotoPageBtn) {
        gotoPageBtn.addEventListener('click', handleGoToPage);
      }
      
      if (pageInput) {
        pageInput.addEventListener('keypress', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault(); // Prevent form submission if it's in a form
            handleGoToPage();
          }
        });
      }

      // Click outside to cancel page input - store reference for cleanup
      if (pageNavigationGroup && pageIndicator) {
        const clickOutsideHandler = function(event) {
          // Don't interfere with menu overlay
          if (menuOverlay && menuOverlay.classList.contains('show')) {
            return;
          }
          
          if (pageNavigationGroup.style.display === 'block') {
            const isClickInsideNavGroup = pageNavigationGroup.contains(event.target);
            const isClickOnPageIndicator = pageIndicator.contains(event.target);
            if (!isClickInsideNavGroup && !isClickOnPageIndicator) {
              switchToPageDisplayView();
            }
          }
        };
        
        // Remove existing listener if it exists
        if (window.pdfClickOutsideHandler) {
          document.removeEventListener('click', window.pdfClickOutsideHandler, true);
        }
        
        window.pdfClickOutsideHandler = clickOutsideHandler;
        document.addEventListener('click', clickOutsideHandler, true);
      }

      if (pageInputErrorIcon) {
        pageInputErrorIcon.addEventListener('click', () => {
          if (pageInputErrorIcon.style.display !== 'none' && pageInputErrorIcon.title) {
            alert(pageInputErrorIcon.title);
          }
        });
      }

      // --- NEW: Hamburger Menu & TTS Functionality ---
      // Note: All variables moved to global scope to fix access issues

      // Function to initialize menu elements and event listeners
      function initializeMenuElements() {
        // Prevent double initialization
        if (menuInitialized) {
          console.log('Menu already initialized, skipping...');
          return;
        }
        
        // Get menu elements
        menuBtn = document.getElementById('menu-btn');
        menuOverlay = document.getElementById('pdf-menu-overlay');
        menuModal = document.querySelector('.pdf-menu-modal');
        menuCloseBtn = document.getElementById('menu-close-btn');
        ttsMenuSection = document.getElementById('tts-menu-section');
        readingModeInputs = document.querySelectorAll('input[name="reading-mode"]');
        ttsPlayPauseBtn = document.getElementById('tts-play-pause');
        ttsStopBtn = document.getElementById('tts-stop');
        voiceSelector = document.getElementById('voice-selector');
        speedSelector = document.getElementById('speed-selector');
        autoAdvanceCheckbox = document.getElementById('auto-advance');
        highlightColorInput = document.getElementById('highlight-color');

        console.log('Menu elements found:', {
          menuBtn: !!menuBtn,
          menuOverlay: !!menuOverlay,
          menuModal: !!menuModal,
          menuCloseBtn: !!menuCloseBtn,
          ttsMenuSection: !!ttsMenuSection
        });

        // Set up event listeners
        setupMenuEventListeners();
        
        // Mark as initialized
        menuInitialized = true;
        console.log('Menu initialization completed');
      }

      // Voice loading state management
      let voiceLoadingAttempts = 0;
      let maxVoiceLoadingAttempts = 10;
      let voiceLoadingInterval = null;
      let voicesLoaded = false;
      let webTTSFallback = false;
      let webTTSEnabled = false;

      // Test TTS functionality with voice availability check
      function testTTS() {
        console.log('Testing basic TTS functionality...');
        if (!window.speechSynthesis) {
          console.error('Speech synthesis not available');
          showTTSError('Speech synthesis is not supported in this browser.');
          return false;
        }
        
        const voices = speechSynthesis.getVoices();
        if (voices.length === 0) {
          console.warn('No voices available for TTS test');
          return false;
        }
        
        try {
          const testUtterance = new SpeechSynthesisUtterance('Testing speech synthesis');
          testUtterance.volume = 0.1; // Very quiet test
          testUtterance.rate = 2; // Fast test
          
          testUtterance.onstart = () => {
            console.log('‚úÖ TTS test successful - speech synthesis is working');
            hideTTSError();
          };
          
          testUtterance.onerror = (event) => {
            console.error('‚ùå TTS test failed:', event.error);
            showTTSError(`TTS test failed: ${event.error}`);
          };
          
          speechSynthesis.speak(testUtterance);
          return true;
        } catch (error) {
          console.error('‚ùå TTS test error:', error);
          showTTSError(`TTS error: ${error.message}`);
          return false;
        }
      }

      // Show TTS error message to user with enhanced guidance
      function showTTSError(message) {
        let errorDiv = document.getElementById('tts-error-message');
        if (!errorDiv) {
          errorDiv = document.createElement('div');
          errorDiv.id = 'tts-error-message';
          errorDiv.style.cssText = `
            background: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            max-width: 600px;
            line-height: 1.5;
          `;
          
          // Insert after the TTS controls section
          const ttsSection = document.querySelector('.tts-controls-section');
          if (ttsSection) {
            ttsSection.parentNode.insertBefore(errorDiv, ttsSection.nextSibling);
          }
        }
        
        errorDiv.innerHTML = `
          <div style="margin-bottom: 15px;">
            <strong>‚ö†Ô∏è Text-to-Speech Not Available</strong><br>
            ${message}
          </div>
          
          <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 12px; border-radius: 4px; margin: 10px 0;">
            <strong>üí° Alternative Options:</strong><br>
            ‚Ä¢ Use your browser's built-in "Read Aloud" extension<br>
            ‚Ä¢ Copy text and paste into online TTS services<br>
            ‚Ä¢ Use screen reader software if available<br>
            ‚Ä¢ Switch to "Read" mode for manual reading
          </div>
          
          <details style="margin-top: 10px;">
            <summary style="cursor: pointer; font-weight: bold;">üîß Technical Setup Instructions</summary>
            <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
              <strong>Quick Browser Test:</strong><br>
              Open browser console (F12) and run: <code>speechSynthesis.getVoices().length</code><br>
              If it returns 0, your system needs TTS voices installed.<br><br>
              
              <strong>Installation Commands:</strong><br>
              <strong>Ubuntu/Debian:</strong> <code>sudo apt install espeak espeak-data</code><br>
              <strong>Fedora:</strong> <code>sudo dnf install espeak espeak-devel</code><br>
              <strong>Arch:</strong> <code>sudo pacman -S espeak espeak-ng</code><br><br>
              
              <strong>After installation:</strong> Restart your browser completely.
            </div>
          </details>
        `;
        errorDiv.style.display = 'block';
      }

      // Hide TTS error message
      function hideTTSError() {
        const errorDiv = document.getElementById('tts-error-message');
        if (errorDiv) {
          errorDiv.style.display = 'none';
        }
      }

      // Show TTS success message
      function showTTSSuccess(message) {
        let successDiv = document.getElementById('tts-success-message');
        if (!successDiv) {
          successDiv = document.createElement('div');
          successDiv.id = 'tts-success-message';
          successDiv.style.cssText = `
            background: #d4edda;
            border: 1px solid #28a745;
            color: #155724;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
            display: none;
          `;
          
          // Insert after the TTS controls section
          const ttsSection = document.querySelector('.tts-controls-section');
          if (ttsSection) {
            ttsSection.parentNode.insertBefore(successDiv, ttsSection.nextSibling);
          }
        }
        
        successDiv.innerHTML = `
          <strong>‚úÖ ${message}</strong>
        `;
        successDiv.style.display = 'block';
        
        // Hide after 5 seconds
        setTimeout(() => {
          successDiv.style.display = 'none';
        }, 5000);
      }

      // Web-based TTS fallback using ResponsiveVoice API
      function initializeWebTTS() {
        console.log('Initializing web-based TTS fallback...');
        
        // Check if ResponsiveVoice is already loaded
        if (window.responsiveVoice) {
          console.log('‚úÖ ResponsiveVoice already available');
          webTTSEnabled = true;
          return Promise.resolve(true);
        }
        
        return new Promise((resolve) => {
          // Load ResponsiveVoice script
          const script = document.createElement('script');
          script.src = 'https://code.responsivevoice.org/responsivevoice.js?key=FREE';
          script.onload = () => {
            console.log('‚úÖ ResponsiveVoice loaded successfully');
            webTTSEnabled = true;
            
            // Wait for ResponsiveVoice to initialize
            const checkReady = () => {
              if (window.responsiveVoice && window.responsiveVoice.voiceSupport()) {
                console.log('‚úÖ ResponsiveVoice ready for use');
                resolve(true);
              } else {
                setTimeout(checkReady, 100);
              }
            };
            checkReady();
          };
          script.onerror = () => {
            console.error('‚ùå Failed to load ResponsiveVoice');
            resolve(false);
          };
          document.head.appendChild(script);
        });
      }

      // Web TTS speak function
      function webTTSSpeak(text) {
        if (!webTTSEnabled || !window.responsiveVoice) {
          console.error('Web TTS not available');
          return false;
        }
        
        try {
          // Stop any existing speech
          window.responsiveVoice.cancel();
          
          // Configure voice settings
          const voiceSettings = {
            rate: speechRate,
            pitch: 1,
            volume: 1,
            onstart: () => {
              console.log('‚úÖ Web TTS started successfully');
              isPlaying = true;
              updateTtsControlsInMenu();
              hideTTSError();
            },
            onend: () => {
              console.log('Web TTS ended');
              isPlaying = false;
              updateTtsControlsInMenu();
              
              // Auto-advance to next page if enabled
              if (autoAdvance && currentPageNum < totalPages) {
                setTimeout(async () => {
                  await renderPage(currentPageNum + 1);
                  currentPageText = ''; // Reset text for new page
                  if (currentReadingMode === 'audio' || currentReadingMode === 'video') {
                    startTTS();
                  }
                }, 1000);
              }
            },
            onerror: (error) => {
              console.error('‚ùå Web TTS error:', error);
              isPlaying = false;
              updateTtsControlsInMenu();
              showTTSError(`Web TTS failed: ${error}`);
            }
          };
          
          // Use a high-quality voice
          window.responsiveVoice.speak(text, "US English Female", voiceSettings);
          return true;
        } catch (error) {
          console.error('Web TTS speak error:', error);
          showTTSError(`Web TTS error: ${error.message}`);
          return false;
        }
      }

      // Stop web TTS
      function stopWebTTS() {
        if (webTTSEnabled && window.responsiveVoice) {
          window.responsiveVoice.cancel();
          isPlaying = false;
          updateTtsControlsInMenu();
        }
      }

      // Pause/Resume web TTS
      function pauseResumeWebTTS() {
        if (!webTTSEnabled || !window.responsiveVoice) {
          return false;
        }
        
        if (window.responsiveVoice.isPlaying()) {
          window.responsiveVoice.pause();
          console.log('Web TTS paused');
        } else {
          window.responsiveVoice.resume();
          console.log('Web TTS resumed');
        }
        updateTtsControlsInMenu();
        return true;
      }

      // Force voice loading with retries and system detection
      function forceVoiceLoading() {
        return new Promise((resolve) => {
          console.log(`Voice loading attempt ${voiceLoadingAttempts + 1}/${maxVoiceLoadingAttempts}`);
          
          const voices = speechSynthesis.getVoices();
          if (voices.length > 0) {
            console.log('‚úÖ Voices loaded successfully:', voices.length);
            voicesLoaded = true;
            clearInterval(voiceLoadingInterval);
            resolve(voices);
            return;
          }
          
          voiceLoadingAttempts++;
          
          if (voiceLoadingAttempts >= maxVoiceLoadingAttempts) {
            console.warn('‚ùå Failed to load voices after maximum attempts');
            clearInterval(voiceLoadingInterval);
            
            // Provide system-specific guidance
            const userAgent = navigator.userAgent.toLowerCase();
            let systemGuidance = '';
            
            if (userAgent.includes('linux')) {
              systemGuidance = `
                <strong>Linux System Detected:</strong><br>
                Install TTS packages: <code>sudo apt install espeak espeak-data</code><br>
                Or for better voices: <code>sudo apt install festival festvox-kallpc16k</code><br>
                Then restart your browser.
              `;
            } else if (userAgent.includes('mac')) {
              systemGuidance = `
                <strong>macOS System Detected:</strong><br>
                1. Go to System Preferences ‚Üí Accessibility ‚Üí Speech<br>
                2. Enable "Speak selected text when the key is pressed"<br>
                3. Download additional voices in System Voice settings<br>
                4. Restart your browser.
              `;
            } else if (userAgent.includes('win')) {
              systemGuidance = `
                <strong>Windows System Detected:</strong><br>
                1. Go to Settings ‚Üí Time & Language ‚Üí Speech<br>
                2. Download additional voices<br>
                3. Or install Microsoft Speech Platform Runtime<br>
                4. Restart your browser.
              `;
            } else {
              systemGuidance = `
                <strong>System-specific TTS setup required:</strong><br>
                Your operating system may need TTS voices installed.<br>
                Check your system's accessibility or speech settings.
              `;
            }
            
            showTTSError(`No speech voices found on your system. ${systemGuidance}`);
            resolve([]);
            return;
          }
          
          // Try different methods to trigger voice loading
          if (voiceLoadingAttempts === 1) {
            // Method 1: Create and cancel a dummy utterance
            const dummy = new SpeechSynthesisUtterance('');
            speechSynthesis.speak(dummy);
            speechSynthesis.cancel();
          } else if (voiceLoadingAttempts === 2) {
            // Method 2: Try to access voices multiple times
            for (let i = 0; i < 5; i++) {
              speechSynthesis.getVoices();
            }
          } else if (voiceLoadingAttempts === 3) {
            // Method 3: Try with a longer dummy utterance
            const dummy = new SpeechSynthesisUtterance('test voice loading');
            dummy.volume = 0;
            speechSynthesis.speak(dummy);
            speechSynthesis.cancel();
          }
          
          // Continue trying
          setTimeout(() => forceVoiceLoading().then(resolve), 300);
        });
      }

      // Load available voices with robust error handling
      function loadVoices() {
        availableVoices = speechSynthesis.getVoices();
        console.log('Available voices:', availableVoices.length);
        
        if (voiceSelector) {
          if (availableVoices.length > 0) {
            voiceSelector.innerHTML = '<option value="">Default Voice</option>';
            availableVoices.forEach((voice, index) => {
              const option = document.createElement('option');
              option.value = index;
              option.textContent = `${voice.name} (${voice.lang})`;
              if (voice.default) {
                option.selected = true;
                selectedVoice = voice;
              }
              voiceSelector.appendChild(option);
            });
            console.log('Voice selector populated with', availableVoices.length, 'voices');
            hideTTSError();
          } else {
            voiceSelector.innerHTML = '<option value="">Loading voices...</option>';
          }
        }
      }

      // Global Cloud TTS Manager instance
      let cloudTtsManager = null;

      // Initialize TTS functionality using Cloud TTS
      async function initializeTTS() {
        console.log('üåê Initializing Cloud TTS for PDF viewer...');
        
        try {
          // Wait for CloudTtsManager to be available
          let attempts = 0;
          while (!window.CloudTtsManager && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
          }
          
          if (!window.CloudTtsManager) {
            throw new Error('CloudTtsManager not loaded');
          }
          
          // Initialize Cloud TTS Manager
          cloudTtsManager = new window.CloudTtsManager();
          
          // Set up event handlers
          cloudTtsManager.onSuccess = (message) => {
            console.log('‚úÖ Cloud TTS Ready:', message);
            showTTSSuccess(message);
            loadCloudVoices();
            voicesLoaded = true;
          };

          cloudTtsManager.onError = (guidance) => {
            console.log('‚ÑπÔ∏è Cloud TTS Guidance:', guidance);
            showTTSError(guidance.title + ': ' + guidance.message.replace(/<[^>]*>/g, ''));
          };

          cloudTtsManager.onStatusChange = (status) => {
            isPlaying = status.isPlaying;
            updateTtsControlsInMenu();
          };

          cloudTtsManager.onEnd = () => {
            console.log('üîö TTS ended - checking auto-advance...');
            // Auto-advance to next page if enabled
            if (autoAdvance && currentPageNum < totalPages) {
              console.log(`üìñ Auto-advancing from page ${currentPageNum} to ${currentPageNum + 1}`);
              setTimeout(async () => {
                await renderPage(currentPageNum + 1);
                currentPageText = ''; // Reset text for new page
                if (currentReadingMode === 'audio' || currentReadingMode === 'video') {
                  console.log('üîä Auto-starting TTS on new page');
                  startTTS();
                }
              }, 1000);
            } else {
              console.log('‚èπÔ∏è Auto-advance disabled or on last page');
            }
          };

          // Initialize the cloud TTS system
          const success = await cloudTtsManager.initialize();
          
          if (success) {
            console.log('üéâ Cloud TTS initialization successful');
          } else {
            console.log('‚ÑπÔ∏è Cloud TTS initialized with fallback mode');
          }
          
          // Load preferences from localStorage
          loadPreferences();
          
        } catch (error) {
          console.error('‚ùå Cloud TTS initialization failed:', error);
          showTTSError('Failed to initialize text-to-speech. Using fallback mode.');
          
          // Fallback to old system if cloud TTS fails
          await initializeSystemTTSFallback();
        }
      }

      // Load voices from Cloud TTS Manager
      function loadCloudVoices() {
        if (!cloudTtsManager || !voiceSelector) return;
        
        const voices = cloudTtsManager.getVoices();
        console.log('üé§ Loading cloud voices:', voices.length);
        
        voiceSelector.innerHTML = '<option value="">Default Voice</option>';
        voices.forEach((voice, index) => {
          const option = document.createElement('option');
          option.value = voice.name;
          option.textContent = `${voice.name} (${voice.lang})`;
          voiceSelector.appendChild(option);
        });
        
        console.log('Voice selector populated with', voices.length, 'cloud voices');
      }

      // Fallback to system TTS if cloud TTS fails
      async function initializeSystemTTSFallback() {
        console.log('üîÑ Falling back to system TTS...');
        
        if (window.speechSynthesis) {
          speechSynthesis.addEventListener('voiceschanged', () => {
            console.log('Voices changed event fired');
            loadVoices();
            if (!voicesLoaded && speechSynthesis.getVoices().length > 0) {
              voicesLoaded = true;
              testTTS();
            }
          });
          
          loadVoices();
          
          if (availableVoices.length === 0) {
            console.log('No system voices available, attempting force loading...');
            const voices = await forceVoiceLoading();
            if (voices.length > 0) {
              loadVoices();
              setTimeout(() => testTTS(), 500);
            }
          } else {
            voicesLoaded = true;
            setTimeout(() => testTTS(), 500);
          }
        }
        
        loadPreferences();
      }

      // Extract text from current PDF page
      async function extractPageText(pageNum) {
        if (!currentPdfDoc) return '';
        
        try {
          const page = await currentPdfDoc.getPage(pageNum);
          const textContent = await page.getTextContent();
          const textItems = textContent.items.map(item => item.str);
          return textItems.join(' ').replace(/\s+/g, ' ').trim();
        } catch (error) {
          console.error('Error extracting text from page:', error);
          return '';
        }
      }

      // Update TTS controls in menu
      function updateTtsControlsInMenu() {
        if (!ttsPlayPauseBtn) return;
        
        const isCurrentlyPlaying = speechSynthesis.speaking && !speechSynthesis.paused;
        const isPaused = speechSynthesis.paused;
        
        if (isCurrentlyPlaying) {
          ttsPlayPauseBtn.innerHTML = '<span class="icon">‚è∏Ô∏è</span><span class="text">Pause</span>';
        } else if (isPaused) {
          ttsPlayPauseBtn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span><span class="text">Resume</span>';
        } else {
          ttsPlayPauseBtn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span><span class="text">Play</span>';
        }
      }

      // Start TTS for current page using Cloud TTS
      async function startTTS() {
        console.log('üîä Starting Cloud TTS for current page...');
        console.log('currentPageText:', currentPageText);
        console.log('currentPageNum:', currentPageNum);
        console.log('currentPdfDoc:', !!currentPdfDoc);
        
        // Check if Cloud TTS is available
        if (!cloudTtsManager) {
          console.error('Cloud TTS Manager not initialized');
          showTTSError('Text-to-speech is not initialized. Please refresh the page and try again.');
          return;
        }
        
        if (!currentPageText) {
          console.log('Extracting text from page', currentPageNum);
          currentPageText = await extractPageText(currentPageNum);
          console.log('Extracted text:', currentPageText ? currentPageText.substring(0, 100) + '...' : 'null');
        }
        
        if (!currentPageText) {
          console.warn('No text found on current page');
          showTTSError('No text found on this page to read aloud.');
          return;
        }

        try {
          // Get selected voice and speed from UI
          const selectedVoiceName = voiceSelector ? voiceSelector.value : '';
          const selectedSpeed = speedSelector ? parseFloat(speedSelector.value) : 1.0;
          
          console.log(`üîä Speaking with Cloud TTS: voice="${selectedVoiceName}", speed=${selectedSpeed}`);
          
          // Use Cloud TTS Manager to speak
          await cloudTtsManager.speak(currentPageText, {
            voice: selectedVoiceName || null,
            rate: selectedSpeed,
            lang: 'en'
          });
          
          console.log('‚úÖ Cloud TTS started successfully');
          hideTTSError();
          
        } catch (error) {
          console.error('‚ùå Cloud TTS failed:', error);
          showTTSError(`Text-to-speech failed: ${error.message}`);
          
          // Try fallback to system TTS
          console.log('üîÑ Attempting system TTS fallback...');
          await startSystemTTSFallback();
        }
      }

      // Add system TTS fallback function
      async function startSystemTTSFallback() {
        if (!window.speechSynthesis) {
          throw new Error('System TTS not available');
        }
        
        console.log('üîÑ Using system TTS fallback...');
        
        // Stop any existing speech
        speechSynthesis.cancel();
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const utterance = new SpeechSynthesisUtterance(currentPageText);
        utterance.rate = speechRate;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        utterance.onstart = () => {
          console.log('‚úÖ System TTS started');
          isPlaying = true;
          updateTtsControlsInMenu();
          hideTTSError();
        };
        
        utterance.onend = () => {
          console.log('System TTS ended');
          isPlaying = false;
          updateTtsControlsInMenu();
          
          // Auto-advance if enabled
          if (autoAdvance && currentPageNum < totalPages) {
            setTimeout(async () => {
              await renderPage(currentPageNum + 1);
              currentPageText = '';
              if (currentReadingMode === 'audio' || currentReadingMode === 'video') {
                startTTS();
              }
            }, 1000);
          }
        };
        
        utterance.onerror = (event) => {
          console.error('‚ùå System TTS error:', event.error);
          isPlaying = false;
          updateTtsControlsInMenu();
          showTTSError(`System TTS failed: ${event.error}`);
        };
        
        speechSynthesis.speak(utterance);
      }

      // Stop TTS (handles cloud and system TTS)
      function stopTTS() {
        console.log('‚èπÔ∏è Stopping TTS...');
        
        if (cloudTtsManager) {
          cloudTtsManager.stop();
        }
        
        // Also stop system TTS as fallback
        if (window.speechSynthesis) {
          speechSynthesis.cancel();
        }
        
        isPlaying = false;
        updateTtsControlsInMenu();
        console.log('TTS stopped');
      }

      // Pause/Resume TTS (handles cloud and system TTS)
      function pauseResumeTTS() {
        console.log('‚è∏Ô∏è‚ñ∂Ô∏è Pause/Resume TTS...');
        
        if (cloudTtsManager) {
          if (isPlaying) {
            cloudTtsManager.pause();
            console.log('Cloud TTS paused');
          } else {
            // If not playing, start TTS
            startTTS();
          }
        } else if (window.speechSynthesis) {
          // Fallback to system TTS
          if (speechSynthesis.speaking && !speechSynthesis.paused) {
            speechSynthesis.pause();
            console.log('System TTS paused');
          } else if (speechSynthesis.paused) {
            speechSynthesis.resume();
            console.log('System TTS resumed');
          } else {
            startTTS();
          }
        }
        
        updateTtsControlsInMenu();
      }

      // Update reading mode
      function updateReadingMode(mode) {
        console.log('updateReadingMode called with mode:', mode);
        currentReadingMode = mode;
        
        // Show/hide TTS controls section
        if (ttsMenuSection) {
          const shouldShow = mode !== 'read';
          ttsMenuSection.style.display = shouldShow ? 'block' : 'none';
          console.log('TTS section display set to:', shouldShow ? 'block' : 'none');
        } else {
          console.error('ttsMenuSection not found!');
        }
        
        // Stop TTS if switching to read-only mode
        if (mode === 'read') {
          console.log('Stopping TTS for read mode');
          stopTTS();
        }
        
        // For audio/video modes, just prepare but don't auto-start
        if (mode === 'audio' || mode === 'video') {
          console.log(`Switched to ${mode} mode - ready for TTS (click Play to start)`);
          currentPageText = ''; // Reset to extract fresh text when user clicks play
          // Don't auto-start - wait for user to click play button
        }
        
        savePreferences();
      }

      // Menu toggle functionality
      function toggleMenu() {
        // Debounce to prevent rapid double-clicks
        const now = Date.now();
        if (now - lastToggleTime < 300) { // 300ms debounce
          console.log('Toggle ignored due to debounce');
          return;
        }
        lastToggleTime = now;
        
        console.log('toggleMenu called, menuOverlay:', menuOverlay);
        if (!menuOverlay) {
          console.error('menuOverlay not found!');
          // Try to find it again
          menuOverlay = document.getElementById('pdf-menu-overlay');
          console.log('Retry finding menuOverlay:', menuOverlay);
          if (!menuOverlay) return;
        }
        
        const isVisible = menuOverlay.classList.contains('show');
        console.log('Menu currently visible:', isVisible);
        
        if (isVisible) {
          closeMenu();
        } else {
          openMenu();
        }
      }

      // Open menu function
      function openMenu() {
        console.log('openMenu() called');
        if (!menuOverlay) {
          console.error('menuOverlay not found in openMenu');
          return;
        }
        
        // Show the overlay
        menuOverlay.classList.add('show');
        console.log('Added show class to overlay');
        
        // Add animation class for smooth entrance
        setTimeout(() => {
          if (menuModal) {
            menuModal.classList.add('menu-modal-open');
            console.log('Added animation class to modal');
          }
        }, 10);
        
        // Prevent body scrolling when modal is open
        document.body.style.overflow = 'hidden';
        
        console.log('Menu opened successfully, overlay classes:', menuOverlay.className);
      }

      // Close menu function
      function closeMenu() {
        console.log('closeMenu() called');
        if (!menuOverlay) {
          console.error('menuOverlay not found in closeMenu');
          return;
        }
        
        console.log('Menu was open, closing...');
        
        // Remove animation class
        if (menuModal) {
          menuModal.classList.remove('menu-modal-open');
        }
        
        // Hide overlay after animation
        setTimeout(() => {
          menuOverlay.classList.remove('show');
          // Restore body scrolling
          document.body.style.overflow = '';
          console.log('Menu closed, overlay classes:', menuOverlay.className);
        }, 200);
        
        console.log('Menu close initiated');
      }


      // Save preferences to localStorage
      function savePreferences() {
        const preferences = {
          readingMode: currentReadingMode,
          voice: voiceSelector ? voiceSelector.value : '',
          speed: speechRate,
          autoAdvance: autoAdvance,
          highlightColor: highlightColor
        };
        
        localStorage.setItem('pdfViewerPreferences', JSON.stringify(preferences));
      }

      // Load preferences from localStorage
      function loadPreferences() {
        try {
          const saved = localStorage.getItem('pdfViewerPreferences');
          if (saved) {
            const preferences = JSON.parse(saved);
            
            // Apply reading mode
            if (preferences.readingMode) {
              currentReadingMode = preferences.readingMode;
              const modeInput = document.querySelector(`input[value="${preferences.readingMode}"]`);
              if (modeInput) {
                modeInput.checked = true;
                updateReadingMode(preferences.readingMode);
              }
            }
            
            // Apply voice selection
            if (preferences.voice && voiceSelector) {
              voiceSelector.value = preferences.voice;
              if (preferences.voice && availableVoices[preferences.voice]) {
                selectedVoice = availableVoices[preferences.voice];
              }
            }
            
            // Apply speed
            if (preferences.speed && speedSelector) {
              speechRate = preferences.speed;
              speedSelector.value = preferences.speed;
            }
            
            // Apply auto-advance
            if (preferences.autoAdvance !== undefined && autoAdvanceCheckbox) {
              autoAdvance = preferences.autoAdvance;
              autoAdvanceCheckbox.checked = preferences.autoAdvance;
            }
            
            // Apply highlight color
            if (preferences.highlightColor && highlightColorInput) {
              highlightColor = preferences.highlightColor;
              highlightColorInput.value = preferences.highlightColor;
            }
            
          }
        } catch (error) {
          console.error('Error loading preferences:', error);
        }
      }

      // Function to set up all menu event listeners
      function setupMenuEventListeners() {
        // Event Listeners for Menu
        if (menuBtn) {
          // Remove any existing listeners first
          if (menuBtn.hasAttribute('data-menu-listener')) {
            console.log('Menu button already has listener, skipping...');
            return;
          }
          
          console.log('Adding click listener to menu button');
          menuBtn.addEventListener('click', (e) => {
            console.log('Menu button clicked!');
            e.stopPropagation();
            e.preventDefault();
            toggleMenu();
          }, true); // Use capture phase to ensure it runs first
          
          // Mark that listener has been added
          menuBtn.setAttribute('data-menu-listener', 'true');
        } else {
          console.error('Menu button not found!');
        }

        // Close menu when clicking close button
        if (menuCloseBtn) {
          menuCloseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeMenu();
          });
        }

        // Close menu when clicking overlay background
        if (menuOverlay) {
          menuOverlay.addEventListener('click', (e) => {
            console.log('Overlay clicked, target:', e.target, 'overlay:', menuOverlay);
            // Only close if clicking the overlay itself, not the modal content
            if (e.target === menuOverlay) {
              console.log('Closing menu due to overlay background click');
              e.stopPropagation();
              closeMenu();
            }
          });
        }

        // Prevent modal content clicks from closing the menu
        if (menuModal) {
          menuModal.addEventListener('click', (e) => {
            console.log('Modal content clicked, preventing propagation');
            e.stopPropagation();
          });
        }

        // Close menu with Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && menuOverlay && menuOverlay.classList.contains('show')) {
            console.log('Escape key pressed, closing menu');
            closeMenu();
          }
        });

        // Reading mode change handlers
        if (readingModeInputs) {
          readingModeInputs.forEach(input => {
            input.addEventListener('change', (e) => {
              if (e.target.checked) {
                updateReadingMode(e.target.value);
              }
            });
          });
        }

        // TTS control handlers
        if (ttsPlayPauseBtn) {
          console.log('Adding click listener to TTS play/pause button');
          ttsPlayPauseBtn.addEventListener('click', (e) => {
            console.log('TTS play/pause button clicked!');
            e.preventDefault();
            e.stopPropagation();
            pauseResumeTTS();
          });
        } else {
          console.error('TTS play/pause button not found!');
        }

        if (ttsStopBtn) {
          console.log('Adding click listener to TTS stop button');
          ttsStopBtn.addEventListener('click', (e) => {
            console.log('TTS stop button clicked!');
            e.preventDefault();
            e.stopPropagation();
            stopTTS();
          });
        } else {
          console.error('TTS stop button not found!');
        }

        if (voiceSelector) {
          voiceSelector.addEventListener('change', (e) => {
            if (e.target.value && availableVoices[e.target.value]) {
              selectedVoice = availableVoices[e.target.value];
            } else {
              selectedVoice = null;
            }
            savePreferences();
          });
        }

        if (speedSelector) {
          speedSelector.addEventListener('change', (e) => {
            speechRate = parseFloat(e.target.value);
            console.log(`üéõÔ∏è Speed changed to ${speechRate}x`);
            savePreferences();
            
            // If currently playing, try to update speed without restarting
            if (isPlaying && (currentReadingMode === 'audio' || currentReadingMode === 'video')) {
              if (cloudTtsManager && cloudTtsManager.setPlaybackRate) {
                // Try to update playback rate of current audio
                const updated = cloudTtsManager.setPlaybackRate(speechRate);
                if (updated) {
                  console.log('‚úÖ Speed updated during playback');
                } else {
                  // Fallback: restart TTS with new speed
                  console.log('üîÑ Restarting TTS with new speed...');
                  stopTTS();
                  setTimeout(() => {
                    startTTS();
                  }, 500);
                }
              } else {
                // Fallback for system TTS or if cloud TTS doesn't support live updates
                console.log('üîÑ Restarting TTS with new speed...');
                stopTTS();
                setTimeout(() => {
                  startTTS();
                }, 500);
              }
            }
          });
        }

        if (autoAdvanceCheckbox) {
          autoAdvanceCheckbox.addEventListener('change', (e) => {
            autoAdvance = e.target.checked;
            savePreferences();
          });
        }

        if (highlightColorInput) {
          highlightColorInput.addEventListener('change', (e) => {
            highlightColor = e.target.value;
            savePreferences();
          });
        }

      }

      // Initialize TTS when PDF is loaded
      initializeTTS();

      // Initialize menu elements and event listeners after PDF is loaded
      initializeMenuElements();

      // Reset page text when page changes (hook into existing render function)
      const originalRenderPage = renderPage;
      renderPage = async function(num, scale = null) {
        currentPageText = ''; // Reset text for new page
        await originalRenderPage(num, scale);
        
        // If in audio/video mode, extract text for new page
        if (currentReadingMode === 'audio' || currentReadingMode === 'video') {
          currentPageText = await extractPageText(num);
        }
      };

    } catch (error) {
      console.error("Error loading or rendering PDF:", error);
      const container = document.getElementById('pdf-viewer-container');
      if (container) {
        container.innerHTML = `<p>Error loading PDF: ${error.message}.</p>`;
      }
    }
  }

  // Initialize immediately
  initializePdfViewer();

  // Reinitialize after view transitions
  document.addEventListener('astro:page-load', () => {
    console.log('Page loaded, reinitializing PDF viewer');
    initializePdfViewer();
  });

  // Also reinitialize on beforeunload to ensure cleanup
  window.addEventListener('beforeunload', () => {
    cleanupPdfViewer();
  });
})();</script>  </div>  </article>  </div> </main> </div> <footer data-astro-cid-sz7xmlte> <div class="footer-container library-page-footer" data-astro-cid-sz7xmlte> <div class="footer-columns" data-astro-cid-sz7xmlte> <div class="column" data-astro-cid-sz7xmlte> <h5 data-astro-cid-sz7xmlte>Menu</h5> <ul data-astro-cid-sz7xmlte> <li data-astro-cid-sz7xmlte><a href="/" data-astro-cid-sz7xmlte>Home</a></li> <li data-astro-cid-sz7xmlte><a href="/library/" data-astro-cid-sz7xmlte>Library</a></li> <li data-astro-cid-sz7xmlte><a href="/about/" data-astro-cid-sz7xmlte>About</a></li> <li data-astro-cid-sz7xmlte><a href="/contact/" data-astro-cid-sz7xmlte>Contact</a></li> </ul> </div> <div class="column" data-astro-cid-sz7xmlte> <h5 data-astro-cid-sz7xmlte>References</h5> <ul data-astro-cid-sz7xmlte> <li data-astro-cid-sz7xmlte><a href="https://arithmoi.org" data-astro-cid-sz7xmlte>Arithmoi Website</a></li> <li data-astro-cid-sz7xmlte><a href="/privacy-policy/" data-astro-cid-sz7xmlte>Privacy Policy</a></li> <li data-astro-cid-sz7xmlte><a href="/terms-conditions/" data-astro-cid-sz7xmlte>Terms and Conditions</a></li> <li data-astro-cid-sz7xmlte><a href="/social/" data-astro-cid-sz7xmlte>Social Links</a></li> </ul> </div> </div> <div class="copyright" data-astro-cid-sz7xmlte> <p data-astro-cid-sz7xmlte>&copy; 2025 Arithmoi Foundation. All rights reserved.</p> </div> </div></footer>  <script>
  function initializeSidebar() {
    const sidebarToggle = document.querySelector('.sidebar-toggle');
    const sidebar = document.getElementById('sidebar'); // ID is in Sidebar.astro
    const body = document.body;

    if (sidebarToggle && sidebar) {
      // Remove existing listeners by cloning the element
      const newSidebarToggle = sidebarToggle.cloneNode(true);
      sidebarToggle.parentNode.replaceChild(newSidebarToggle, sidebarToggle);
      
      newSidebarToggle.addEventListener('click', () => {
        const isExpanded = newSidebarToggle.getAttribute('aria-expanded') === 'true' || false;
        newSidebarToggle.setAttribute('aria-expanded', String(!isExpanded));
        sidebar.classList.toggle('is-active');
        newSidebarToggle.classList.toggle('is-active');
        // Uncomment below to use body overlay
        // body.classList.toggle('sidebar-open-overlay');
      });
    }

    // Remove existing click listener and add new one
    const existingClickHandler = window.sidebarClickHandler;
    if (existingClickHandler) {
      document.removeEventListener('click', existingClickHandler);
    }

    // Optional: Close sidebar if user clicks outside of it on mobile
    window.sidebarClickHandler = function(event) {
      const currentSidebar = document.getElementById('sidebar');
      const currentSidebarToggle = document.querySelector('.sidebar-toggle');
      
      if (currentSidebar && currentSidebarToggle && currentSidebar.classList.contains('is-active')) {
        const isClickInsideSidebar = currentSidebar.contains(event.target);
        const isClickOnToggler = currentSidebarToggle.contains(event.target);

        if (!isClickInsideSidebar && !isClickOnToggler) {
          currentSidebar.classList.remove('is-active');
          currentSidebarToggle.classList.remove('is-active');
          currentSidebarToggle.setAttribute('aria-expanded', 'false');
          // Uncomment below to use body overlay
          // body.classList.remove('sidebar-open-overlay');
        }
      }
    };
    
    document.addEventListener('click', window.sidebarClickHandler);
  }

  // Initialize on page load
  initializeSidebar();

  // Reinitialize after view transitions
  document.addEventListener('astro:page-load', initializeSidebar);
</script> </body> </html>  