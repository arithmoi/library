---
// src/components/UniversalPdfViewer.astro
export interface Props {
  pdfUrl: string;
  mode?: 'read' | 'audio' | 'video';
  title?: string;
}

const { pdfUrl, mode = 'read', title = 'PDF Document' } = Astro.props;
---

<div class="universal-pdf-viewer" data-mode={mode} data-pdf-url={pdfUrl}>
  <!-- PDF Container with Browser Native Viewer -->
  <div class="pdf-container">
    <embed 
      src={pdfUrl} 
      type="application/pdf" 
      class="pdf-native-viewer"
      title={title}
    />
    <!-- Fallback for browsers that don't support PDF embedding -->
    <div class="pdf-fallback" style="display: none;">
      <div class="fallback-message">
        <h3>üìÑ PDF Viewer</h3>
        <p>Your browser doesn't support embedded PDFs.</p>
        <a href={pdfUrl} target="_blank" class="download-link">
          üì• Download PDF
        </a>
      </div>
    </div>
  </div>
  
  <!-- Mode Controls -->
  <div class="mode-controls">
    <button data-mode="read" class="mode-btn active">
      <span class="icon">üìñ</span>
      <span class="text">Read</span>
    </button>
    <button data-mode="audio" class="mode-btn">
      <span class="icon">üîä</span>
      <span class="text">Audio</span>
    </button>
    <button data-mode="video" class="mode-btn">
      <span class="icon">üé¨</span>
      <span class="text">Video</span>
    </button>
  </div>

  <!-- Audio Controls (hidden by default) -->
  <div class="audio-controls" style="display: none;">
    <div class="playback-controls">
      <button id="play-pause-btn" class="control-btn primary">
        <span class="icon">‚ñ∂Ô∏è</span>
        <span class="text">Play</span>
      </button>
      <button id="stop-btn" class="control-btn">
        <span class="icon">‚èπÔ∏è</span>
        <span class="text">Stop</span>
      </button>
      <button id="prev-page-btn" class="control-btn">
        <span class="icon">‚èÆÔ∏è</span>
        <span class="text">Previous</span>
      </button>
      <button id="next-page-btn" class="control-btn">
        <span class="icon">‚è≠Ô∏è</span>
        <span class="text">Next</span>
      </button>
    </div>
    
    <div class="audio-settings">
      <div class="setting-group">
        <label for="voice-select">üé§ Voice:</label>
        <select id="voice-select" class="setting-select">
          <option value="">Best Available Voice</option>
        </select>
      </div>
      
      <div class="setting-group">
        <label for="speed-select">‚ö° Speed:</label>
        <select id="speed-select" class="setting-select">
          <option value="0.6">0.6x (Very Slow)</option>
          <option value="0.75">0.75x (Slow)</option>
          <option value="0.9" selected>0.9x (Natural)</option>
          <option value="1.0">1.0x (Normal)</option>
          <option value="1.1">1.1x (Slightly Fast)</option>
          <option value="1.25">1.25x (Fast)</option>
          <option value="1.5">1.5x (Very Fast)</option>
        </select>
      </div>
      
      <div class="setting-group">
        <label for="pitch-select">üéµ Pitch:</label>
        <select id="pitch-select" class="setting-select">
          <option value="0.8">0.8 (Lower)</option>
          <option value="0.9">0.9 (Slightly Lower)</option>
          <option value="1.0" selected>1.0 (Normal)</option>
          <option value="1.1">1.1 (Slightly Higher)</option>
          <option value="1.2">1.2 (Higher)</option>
        </select>
      </div>
      
      <div class="setting-group checkbox-group">
        <label class="checkbox-label">
          <input type="checkbox" id="auto-advance" checked>
          <span class="checkmark"></span>
          <span class="text">üîÑ Auto-advance pages</span>
        </label>
      </div>
    </div>
  </div>

  <!-- Video Controls (hidden by default) -->
  <div class="video-controls" style="display: none;">
    <div class="playback-controls">
      <button id="video-play-pause-btn" class="control-btn primary">
        <span class="icon">‚ñ∂Ô∏è</span>
        <span class="text">Play</span>
      </button>
      <button id="video-stop-btn" class="control-btn">
        <span class="icon">‚èπÔ∏è</span>
        <span class="text">Stop</span>
      </button>
    </div>
    
    <div class="video-settings">
      <div class="setting-group">
        <label for="highlight-mode">‚ú® Highlight:</label>
        <select id="highlight-mode" class="setting-select">
          <option value="word" selected>Word by Word</option>
          <option value="sentence">Sentence by Sentence</option>
          <option value="off">No Highlighting</option>
        </select>
      </div>
      
      <div class="setting-group checkbox-group">
        <label class="checkbox-label">
          <input type="checkbox" id="video-auto-advance" checked>
          <span class="checkmark"></span>
          <span class="text">üîÑ Auto-advance pages</span>
        </label>
      </div>
    </div>
  </div>

  <!-- Status Display -->
  <div class="status-display" style="display: none;">
    <div class="status-message"></div>
  </div>

  <!-- Progress Indicator -->
  <div class="progress-indicator" style="display: none;">
    <div class="progress-bar">
      <div class="progress-fill"></div>
    </div>
    <div class="progress-text">
      <span class="current-page">1</span> / <span class="total-pages">1</span>
    </div>
  </div>
</div>

<script>
  // Enhanced TTS Manager with robust voice loading and error handling
  class EnhancedTTSManager {
    constructor() {
      this.isPlaying = false;
      this.isPaused = false;
      this.currentUtterance = null;
      this.availableVoices = [];
      this.isInitialized = false;
      this.voicesLoaded = false;
      this.initializationPromise = null;
    }

    async initialize() {
      // Return existing promise if already initializing
      if (this.initializationPromise) {
        return this.initializationPromise;
      }

      this.initializationPromise = this._doInitialize();
      return this.initializationPromise;
    }

    async _doInitialize() {
      if (this.isInitialized) return true;

      if (!window.speechSynthesis) {
        console.warn('‚ùå Speech synthesis not supported in this browser');
        return false;
      }

      console.log('üé§ Initializing Enhanced TTS Manager...');
      
      try {
        // Force voice loading with multiple strategies
        await this.loadVoicesWithFallback();
        
        this.isInitialized = true;
        const hasVoices = this.availableVoices.length > 0;
        
        console.log(`‚úÖ TTS Manager initialized with ${this.availableVoices.length} voices`);
        if (!hasVoices) {
          console.warn('‚ö†Ô∏è No voices available - will use system default voice');
        }
        
        return true;
      } catch (error) {
        console.error('‚ùå TTS initialization failed:', error);
        return false;
      }
    }

    async loadVoicesWithFallback() {
      // Strategy 1: Try immediate voice loading
      this.availableVoices = speechSynthesis.getVoices();
      if (this.availableVoices.length > 0) {
        console.log('‚úÖ Voices loaded immediately');
        return;
      }

      // Strategy 2: Wait for voiceschanged event
      console.log('üîÑ Waiting for voices to load...');
      await new Promise((resolve) => {
        let attempts = 0;
        const maxAttempts = 100;
        
        const checkVoices = () => {
          attempts++;
          this.availableVoices = speechSynthesis.getVoices();
          
          if (this.availableVoices.length > 0) {
            console.log(`‚úÖ Voices loaded after ${attempts} attempts`);
            resolve();
          } else if (attempts >= maxAttempts) {
            console.warn(`‚ö†Ô∏è No voices found after ${maxAttempts} attempts`);
            resolve();
          } else {
            setTimeout(checkVoices, 50);
          }
        };

        // Listen for voice changes
        speechSynthesis.addEventListener('voiceschanged', checkVoices, { once: true });
        
        // Start checking immediately
        checkVoices();
        
        // Strategy 3: Force voice loading by speaking empty text
        try {
          const dummyUtterance = new SpeechSynthesisUtterance('');
          speechSynthesis.speak(dummyUtterance);
          speechSynthesis.cancel();
        } catch (e) {
          console.log('Dummy utterance failed, continuing...');
        }
      });
    }

    async speak(text, options = {}) {
      console.log('üó£Ô∏è Enhanced TTS speak called with:', {
        text: text.substring(0, 50) + '...',
        options,
        voicesAvailable: this.availableVoices.length
      });
      
      // Ensure initialization
      const initialized = await this.initialize();
      if (!initialized) {
        throw new Error('TTS initialization failed');
      }

      return new Promise((resolve, reject) => {
        if (!window.speechSynthesis) {
          reject(new Error('Speech synthesis not supported'));
          return;
        }

        // Stop any current speech
        this.stop();
        
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Set voice options
        utterance.rate = Math.max(0.1, Math.min(2.0, options.rate || 0.9));
        utterance.pitch = Math.max(0.0, Math.min(2.0, options.pitch || 1.0));
        utterance.volume = Math.max(0.0, Math.min(1.0, options.volume || 0.85));
        
        // Try to set a voice
        if (options.voice && this.availableVoices.includes(options.voice)) {
          utterance.voice = options.voice;
          console.log('üé§ Using selected voice:', options.voice.name);
        } else if (this.availableVoices.length > 0) {
          // Use the first available voice
          utterance.voice = this.availableVoices[0];
          console.log('üé§ Using default voice:', this.availableVoices[0].name);
        } else {
          console.log('üé§ Using system default voice (no voices enumerated)');
        }

        // Set up event handlers
        utterance.onstart = () => {
          console.log('‚ñ∂Ô∏è Speech started successfully');
          this.isPlaying = true;
          this.isPaused = false;
        };

        utterance.onend = () => {
          console.log('‚èπÔ∏è Speech ended successfully');
          this.isPlaying = false;
          this.isPaused = false;
          resolve();
        };

        utterance.onerror = (event) => {
          console.error('‚ùå Speech error:', event.error, event);
          this.isPlaying = false;
          this.isPaused = false;
          
          // Provide more specific error messages
          let errorMessage = `Speech error: ${event.error}`;
          if (event.error === 'synthesis-failed') {
            errorMessage = 'Speech synthesis failed. This may be due to browser limitations or system TTS issues.';
          } else if (event.error === 'network') {
            errorMessage = 'Network error during speech synthesis.';
          } else if (event.error === 'synthesis-unavailable') {
            errorMessage = 'Speech synthesis is not available on this system.';
          }
          
          reject(new Error(errorMessage));
        };

        // Store current utterance
        this.currentUtterance = utterance;
        
        try {
          console.log('üöÄ Starting speech synthesis...');
          speechSynthesis.speak(utterance);
          
          // Fallback timeout to detect if speech never starts
          setTimeout(() => {
            if (!this.isPlaying && utterance === this.currentUtterance) {
              console.warn('‚ö†Ô∏è Speech may have failed to start, checking status...');
              if (speechSynthesis.speaking) {
                console.log('‚úÖ Speech is actually running');
                this.isPlaying = true;
              } else {
                console.error('‚ùå Speech failed to start');
                reject(new Error('Speech failed to start within timeout'));
              }
            }
          }, 1000);
          
        } catch (error) {
          console.error('‚ùå Exception during speech synthesis:', error);
          reject(error);
        }
      });
    }

    pause() {
      if (this.isPlaying && !this.isPaused && speechSynthesis.speaking) {
        try {
          speechSynthesis.pause();
          this.isPaused = true;
          console.log('‚è∏Ô∏è Speech paused');
        } catch (error) {
          console.error('‚ùå Failed to pause speech:', error);
        }
      }
    }

    resume() {
      if (this.isPaused && speechSynthesis.paused) {
        try {
          speechSynthesis.resume();
          this.isPaused = false;
          console.log('‚ñ∂Ô∏è Speech resumed');
        } catch (error) {
          console.error('‚ùå Failed to resume speech:', error);
        }
      }
    }

    stop() {
      if (this.isPlaying || speechSynthesis.speaking) {
        try {
          speechSynthesis.cancel();
          this.isPlaying = false;
          this.isPaused = false;
          this.currentUtterance = null;
          console.log('‚èπÔ∏è Speech stopped');
        } catch (error) {
          console.error('‚ùå Failed to stop speech:', error);
        }
      }
    }

    getStatus() {
      return {
        isPlaying: this.isPlaying,
        isPaused: this.isPaused,
        isInitialized: this.isInitialized,
        voicesAvailable: this.availableVoices.length,
        speechSynthesisState: {
          speaking: speechSynthesis.speaking,
          pending: speechSynthesis.pending,
          paused: speechSynthesis.paused
        }
      };
    }

    getVoices() {
      return this.availableVoices;
    }

    // Get best available voice for the platform
    getBestVoice() {
      if (this.availableVoices.length === 0) return null;

      // Platform-specific voice preferences
      const platform = this.detectPlatform();
      const preferences = {
        mac: ['Alex', 'Samantha', 'Victoria', 'Allison'],
        windows: ['Zira', 'David', 'Mark', 'Hazel'],
        linux: ['espeak', 'festival'],
        android: ['Google', 'Samsung'],
        ios: ['Alex', 'Samantha']
      };

      const preferred = preferences[platform] || [];
      
      // Try to find a preferred voice
      for (const voiceName of preferred) {
        const voice = this.availableVoices.find(v =>
          v.name.toLowerCase().includes(voiceName.toLowerCase())
        );
        if (voice) return voice;
      }

      // Fallback to first English voice
      const englishVoice = this.availableVoices.find(v =>
        v.lang.startsWith('en')
      );
      if (englishVoice) return englishVoice;

      // Last resort: first available voice
      return this.availableVoices[0];
    }

    detectPlatform() {
      const userAgent = navigator.userAgent.toLowerCase();
      const platform = navigator.platform.toLowerCase();
      
      if (userAgent.includes('mac') || platform.includes('mac')) return 'mac';
      if (userAgent.includes('win') || platform.includes('win')) return 'windows';
      if (userAgent.includes('android')) return 'android';
      if (userAgent.includes('iphone') || userAgent.includes('ipad')) return 'ios';
      if (userAgent.includes('linux')) return 'linux';
      return 'unknown';
    }
  }

  class UniversalPdfViewer {
    constructor(container) {
      this.container = container;
      this.pdfUrl = container.dataset.pdfUrl;
      this.currentMode = container.dataset.mode || 'read';
      this.isInitialized = false;
      
      // Core components
      this.ttsManager = new EnhancedTTSManager();
      this.highlighter = null;
      this.touchOptimizer = null;
      
      // State
      this.currentPage = 1;
      this.totalPages = 1;
      this.isPlaying = false;
      this.currentText = '';
    }

    async initialize() {
      if (this.isInitialized) return;

      try {
        console.log('üöÄ Initializing Universal PDF Viewer...');
        
        // Check PDF embed support
        this.checkPdfSupport();
        
        // Initialize TTS
        await this.ttsManager.initialize();
        
        // Setup mode switching
        this.setupModeControls();
        
        // Initialize with current mode
        await this.switchMode(this.currentMode);
        
        // Add CSS styles
        this.injectStyles();
        
        console.log('‚úÖ Universal PDF Viewer initialized');
        this.isInitialized = true;
        
      } catch (error) {
        console.error('‚ùå Universal PDF Viewer initialization failed:', error);
        this.showError('Failed to initialize PDF viewer', error.message);
      }
    }

    checkPdfSupport() {
      const embed = this.container.querySelector('.pdf-native-viewer');
      const fallback = this.container.querySelector('.pdf-fallback');
      
      // Check if browser supports PDF embedding
      const supportsPdf = navigator.mimeTypes['application/pdf'] || 
                         navigator.plugins['Chrome PDF Viewer'] ||
                         navigator.plugins['Adobe Acrobat'];
      
      if (!supportsPdf) {
        embed.style.display = 'none';
        fallback.style.display = 'block';
        console.warn('Browser does not support embedded PDFs, showing fallback');
      }
    }


    setupModeControls() {
      const modeButtons = this.container.querySelectorAll('.mode-btn');
      console.log('Setting up mode controls, found', modeButtons.length, 'buttons');
      
      modeButtons.forEach(button => {
        console.log('Adding click listener to button:', button.dataset.mode);
        button.addEventListener('click', async (e) => {
          e.preventDefault();
          const mode = button.dataset.mode;
          console.log('Mode button clicked:', mode);
          await this.switchMode(mode);
        });
      });
    }

    async switchMode(mode) {
      console.log(`üîÑ Switching to ${mode} mode...`);
      
      // Stop current playback
      this.stop();
      
      // Update UI
      this.updateModeUI(mode);
      
      // Initialize mode-specific functionality
      switch (mode) {
        case 'read':
          console.log('üìñ Initializing read mode');
          await this.initializeReadMode();
          break;
        case 'audio':
          console.log('üîä Initializing audio mode');
          await this.initializeAudioMode();
          break;
        case 'video':
          console.log('üé¨ Initializing video mode');
          await this.initializeVideoMode();
          break;
        default:
          console.warn('Unknown mode:', mode);
      }
      
      this.currentMode = mode;
      this.container.dataset.mode = mode;
      console.log(`‚úÖ Successfully switched to ${mode} mode`);
    }

    updateModeUI(mode) {
      // Update mode buttons
      const modeButtons = this.container.querySelectorAll('.mode-btn');
      modeButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });
      
      // Show/hide controls
      const audioControls = this.container.querySelector('.audio-controls');
      const videoControls = this.container.querySelector('.video-controls');
      
      audioControls.style.display = mode === 'audio' ? 'block' : 'none';
      videoControls.style.display = mode === 'video' ? 'block' : 'none';
    }

    async initializeReadMode() {
      // Pure reading mode - no additional setup needed
      console.log('Read mode initialized');
    }

    async initializeAudioMode() {
      // Setup audio controls
      await this.setupAudioControls();
      console.log('Audio mode initialized');
    }

    async initializeVideoMode() {
      // Setup video controls
      this.setupVideoControls();
      console.log('Video mode initialized');
    }

    async setupAudioControls() {
      const playPauseBtn = this.container.querySelector('#play-pause-btn');
      const stopBtn = this.container.querySelector('#stop-btn');
      const voiceSelect = this.container.querySelector('#voice-select');

      playPauseBtn?.addEventListener('click', () => this.togglePlayback());
      stopBtn?.addEventListener('click', () => this.stop());

      // Populate voice options asynchronously
      await this.populateVoiceOptions(voiceSelect);
    }

    setupVideoControls() {
      const playPauseBtn = this.container.querySelector('#video-play-pause-btn');
      const stopBtn = this.container.querySelector('#video-stop-btn');

      playPauseBtn?.addEventListener('click', () => this.togglePlayback());
      stopBtn?.addEventListener('click', () => this.stop());
    }

    async populateVoiceOptions(voiceSelect) {
      if (!voiceSelect) return;
      
      // Ensure TTS is initialized first
      await this.ttsManager.initialize();
      
      const voices = this.ttsManager.getVoices();
      voiceSelect.innerHTML = '<option value="">Best Available Voice</option>';
      
      if (voices.length === 0) {
        const option = document.createElement('option');
        option.value = "";
        option.textContent = "System Default (No voices enumerated)";
        voiceSelect.appendChild(option);
        console.log('üé§ No voices available for selection, using system default');
        return;
      }
      
      // Get best voice and mark it
      const bestVoice = this.ttsManager.getBestVoice();
      
      voices.forEach((voice, index) => {
        const option = document.createElement('option');
        option.value = index;
        const isBest = bestVoice && voice.name === bestVoice.name;
        option.textContent = `${voice.name} (${voice.lang})${isBest ? ' ‚≠ê' : ''}`;
        if (isBest) {
          option.selected = true;
        }
        voiceSelect.appendChild(option);
      });
      
      console.log(`üé§ Populated ${voices.length} voices in selector`);
    }

    async togglePlayback() {
      console.log('üéµ Toggle playback called, current mode:', this.currentMode);
      if (this.currentMode === 'read') {
        console.log('‚ùå Cannot play in read mode');
        return;
      }
      
      const status = this.ttsManager.getStatus();
      console.log('üìä TTS Status:', status);
      
      if (status.isPlaying && !status.isPaused) {
        console.log('‚è∏Ô∏è Pausing playback');
        this.ttsManager.pause();
      } else if (status.isPaused) {
        console.log('‚ñ∂Ô∏è Resuming playback');
        this.ttsManager.resume();
      } else {
        console.log('üöÄ Starting new playback');
        await this.startReading();
      }
      
      this.updatePlaybackUI();
    }

    async startReading() {
      console.log('üìñ Starting to read...');
      // For demo purposes, read some sample text
      const sampleText = "This is a demonstration of the audiobook functionality. The PDF viewer now supports text-to-speech reading with voice selection and playback controls. The enhanced TTS system automatically selects the best available voice for your platform and provides robust error handling.";
      
      try {
        const speedSelect = this.container.querySelector('#speed-select');
        const pitchSelect = this.container.querySelector('#pitch-select');
        const voiceSelect = this.container.querySelector('#voice-select');
        
        const options = {
          rate: speedSelect ? parseFloat(speedSelect.value) : 0.9,
          pitch: pitchSelect ? parseFloat(pitchSelect.value) : 1.0
        };
        
        console.log('üéõÔ∏è TTS Options:', options);
        
        // Handle voice selection
        if (voiceSelect && voiceSelect.value && voiceSelect.value !== "") {
          const voices = this.ttsManager.getVoices();
          const selectedIndex = parseInt(voiceSelect.value);
          if (selectedIndex >= 0 && selectedIndex < voices.length) {
            options.voice = voices[selectedIndex];
            console.log('üé§ Using selected voice:', options.voice?.name);
          }
        } else {
          // Use best available voice
          const bestVoice = this.ttsManager.getBestVoice();
          if (bestVoice) {
            options.voice = bestVoice;
            console.log('üé§ Using best voice:', bestVoice.name);
          }
        }
        
        console.log('üó£Ô∏è Speaking text:', sampleText.substring(0, 50) + '...');
        await this.ttsManager.speak(sampleText, options);
        console.log('‚úÖ Speech completed successfully');
        
        // Update UI to reflect completion
        this.updatePlaybackUI();
        
      } catch (error) {
        console.error('‚ùå Failed to start reading:', error);
        this.showError('Speech Error', error.message);
        
        // Reset UI on error
        this.updatePlaybackUI();
      }
    }

    async stop() {
      if (this.currentMode === 'read') return;
      
      this.ttsManager.stop();
      this.updatePlaybackUI();
    }

    updatePlaybackUI() {
      const status = this.ttsManager.getStatus();
      const playPauseBtn = this.container.querySelector(
        this.currentMode === 'audio' ? '#play-pause-btn' : '#video-play-pause-btn'
      );
      
      if (playPauseBtn) {
        const icon = playPauseBtn.querySelector('.icon');
        const text = playPauseBtn.querySelector('.text');
        
        if (status.isPlaying && !status.isPaused) {
          icon.textContent = '‚è∏Ô∏è';
          text.textContent = 'Pause';
        } else if (status.isPaused) {
          icon.textContent = '‚ñ∂Ô∏è';
          text.textContent = 'Resume';
        } else {
          icon.textContent = '‚ñ∂Ô∏è';
          text.textContent = 'Play';
        }
      }
    }

    toggleFullscreen() {
      if (!document.fullscreenElement) {
        this.container.requestFullscreen().catch(err => {
          console.log('Fullscreen request failed:', err);
        });
      } else {
        document.exitFullscreen().catch(err => {
          console.log('Exit fullscreen failed:', err);
        });
      }
    }

    toggleModeControls() {
      const modeControls = this.container.querySelector('.mode-controls');
      if (modeControls) {
        modeControls.style.display = 
          modeControls.style.display === 'none' ? 'flex' : 'none';
      }
    }

    showError(title, message) {
      const statusDisplay = this.container.querySelector('.status-display');
      const statusMessage = this.container.querySelector('.status-message');
      
      if (statusDisplay && statusMessage) {
        statusMessage.innerHTML = `
          <div class="error-message">
            <h4>üö® ${title}</h4>
            <p>${message}</p>
            <div class="error-actions">
              <button onclick="this.closest('.status-display').style.display='none'" class="dismiss-btn">
                ‚úï Dismiss
              </button>
            </div>
          </div>
        `;
        statusDisplay.style.display = 'block';
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
          if (statusDisplay.style.display !== 'none') {
            statusDisplay.style.display = 'none';
          }
        }, 10000);
      }
      
      // Also log to console for debugging
      console.error(`${title}: ${message}`);
    }

    showSuccess(title, message) {
      const statusDisplay = this.container.querySelector('.status-display');
      const statusMessage = this.container.querySelector('.status-message');
      
      if (statusDisplay && statusMessage) {
        statusMessage.innerHTML = `
          <div class="success-message">
            <h4>‚úÖ ${title}</h4>
            <p>${message}</p>
          </div>
        `;
        statusDisplay.style.display = 'block';
        
        // Auto-hide after 3 seconds
        setTimeout(() => {
          statusDisplay.style.display = 'none';
        }, 3000);
      }
    }

    injectStyles() {
      if (document.querySelector('#universal-pdf-viewer-styles')) return;
      
      const style = document.createElement('style');
      style.id = 'universal-pdf-viewer-styles';
      
      // Add basic highlighting styles
      const highlightStyles = `
        .pdf-word-highlight {
          background-color: rgba(255, 255, 0, 0.3);
          border-radius: 2px;
          transition: background-color 0.2s ease;
        }
        .pdf-sentence-highlight {
          background-color: rgba(0, 123, 255, 0.2);
          border-radius: 3px;
        }
      `;
      
      // Add touch optimization styles
      const touchOptimizationStyles = `
        @media (max-width: 768px) {
          .universal-pdf-viewer .mode-btn,
          .universal-pdf-viewer .control-btn {
            min-height: 44px;
            min-width: 44px;
          }
        }
      `;
      
      style.textContent = highlightStyles + touchOptimizationStyles;
      document.head.appendChild(style);
    }
  }

  // Initialize all PDF viewers on the page
  function initializeViewers() {
    const viewers = document.querySelectorAll('.universal-pdf-viewer');
    console.log('Found', viewers.length, 'PDF viewers to initialize');
    viewers.forEach(container => {
      const viewer = new UniversalPdfViewer(container);
      viewer.initialize().catch(error => {
        console.error('Failed to initialize viewer:', error);
      });
    });
  }

  // Multiple initialization attempts to ensure it works
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeViewers);
  } else {
    initializeViewers();
  }

  // Fallback initialization
  window.addEventListener('load', () => {
    setTimeout(initializeViewers, 100);
  });
</script>

<style>
  .universal-pdf-viewer {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #f8f9fa;
    position: relative;
  }

  .pdf-container {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  .pdf-native-viewer {
    width: 100%;
    height: 100%;
    border: none;
    background: white;
  }

  .pdf-fallback {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    background: white;
  }

  .fallback-message {
    text-align: center;
    padding: 2rem;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
    background: #f8f9fa;
  }

  .download-link {
    display: inline-block;
    margin-top: 1rem;
    padding: 0.5rem 1rem;
    background: #007bff;
    color: white;
    text-decoration: none;
    border-radius: 4px;
    transition: background-color 0.2s;
  }

  .download-link:hover {
    background: #0056b3;
  }

  .mode-controls {
    display: flex;
    gap: 0.5rem;
    padding: 1rem;
    background: white;
    border-top: 1px solid #dee2e6;
    justify-content: center;
  }

  .mode-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border: 2px solid #dee2e6;
    border-radius: 8px;
    background: white;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9rem;
  }

  .mode-btn:hover {
    background: #f8f9fa;
    border-color: #007bff;
  }

  .mode-btn.active {
    background: #007bff;
    color: white;
    border-color: #007bff;
  }

  .audio-controls,
  .video-controls {
    padding: 1rem;
    background: white;
    border-top: 1px solid #dee2e6;
  }

  .playback-controls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    justify-content: center;
  }

  .control-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    background: white;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9rem;
  }

  .control-btn:hover {
    background: #f8f9fa;
    transform: translateY(-1px);
  }

  .control-btn.primary {
    background: #007bff;
    color: white;
    border-color: #007bff;
  }

  .control-btn.primary:hover {
    background: #0056b3;
  }

  .audio-settings,
  .video-settings {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    align-items: center;
  }

  .setting-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .setting-group label {
    font-weight: 500;
    min-width: 60px;
    font-size: 0.9rem;
  }

  .setting-select {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background: white;
    font-size: 0.9rem;
  }

  .checkbox-group {
    justify-content: flex-start;
  }

  .checkbox-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    font-size: 0.9rem;
  }

  .checkbox-label input[type="checkbox"] {
    margin: 0;
  }

  .status-display {
    padding: 1rem;
    background: #fff3cd;
    border-top: 1px solid #ffeaa7;
  }

  .error-message {
    color: #721c24;
    background: #f8d7da;
    border: 1px solid #f5c6cb;
    border-radius: 4px;
    padding: 1rem;
  }

  .error-message h4 {
    margin: 0 0 0.5rem 0;
  }

  .error-message p {
    margin: 0 0 0.5rem 0;
  }

  .success-message {
    color: #155724;
    background: #d4edda;
    border: 1px solid #c3e6cb;
    border-radius: 4px;
    padding: 1rem;
  }

  .success-message h4 {
    margin: 0 0 0.5rem 0;
  }

  .success-message p {
    margin: 0;
  }

  .error-actions {
    margin-top: 0.5rem;
  }

  .dismiss-btn {
    background: #dc3545;
    color: white;
    border: none;
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8rem;
  }

  .dismiss-btn:hover {
    background: #c82333;
  }

  .progress-indicator {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.5rem 1rem;
    background: white;
    border-top: 1px solid #dee2e6;
  }

  .progress-bar {
    flex: 1;
    height: 4px;
    background: #dee2e6;
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: #007bff;
    transition: width 0.3s ease;
  }

  .progress-text {
    font-size: 0.9rem;
    color: #6c757d;
  }

  /* Mobile Responsive Design */
  @media (max-width: 768px) {
    .mode-controls {
      padding: 0.75rem;
      gap: 0.25rem;
    }
    
    .mode-btn {
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
    }
    
    .mode-btn .text {
      display: none;
    }
    
    .audio-controls,
    .video-controls {
      padding: 0.75rem;
    }
    
    .playback-controls {
      flex-wrap: wrap;
      gap: 0.25rem;
    }
    
    .control-btn {
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
      min-height: 44px;
    }
    
    .control-btn .text {
      display: none;
    }
    
    .audio-settings,
    .video-settings {
      grid-template-columns: 1fr;
      gap: 0.75rem;
    }
    
    .setting-group {
      flex-direction: column;
      align-items: stretch;
      gap: 0.25rem;
    }
    
    .setting-group label {
      min-width: auto;
      font-size: 0.8rem;
    }
  }

  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    .universal-pdf-viewer {
      background: #1a1a1a;
    }
    
    .mode-controls,
    .audio-controls,
    .video-controls,
    .progress-indicator {
      background: #2d2d2d;
      border-color: #404040;
    }
    
    .mode-btn,
    .control-btn,
    .setting-select {
      background: #2d2d2d;
      color: #ffffff;
      border-color: #404040;
    }
    
    .mode-btn:hover,
    .control-btn:hover {
      background: #404040;
    }
  }
</style>