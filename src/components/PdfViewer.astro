---
// src/components/PdfViewer.astro
export interface Props {
  pdfUrl: string;
}

const { pdfUrl } = Astro.props;

// Construct the worker URL for PDF.js
const pdfjsWorkerSrc = `/pdf.worker.min.mjs`;
---

<div id="pdf-viewer-container" class="pdf-viewer-container">
  <div class="canvas-wrapper">
    <canvas id="pdf-canvas"></canvas>
  </div>
  <div class="pdf-controls">
    <button id="prev-page">
      <span class="icon"><</span>
      <span class="text">Previous</span>
    </button>
    <div id="page-indicator" class="page-indicator">
      <span id="page-num-display"></span>&nbsp;/&nbsp;<span id="page-count-display"></span>
    </div>
    <div id="page-navigation-group" style="display: none;">
      <div id="page-input-container" class="page-input-container">
        <input type="number" id="page-input" min="1" />
        <button id="goto-page-btn">Go</button>
        <span id="page-input-error-icon" class="page-input-error-icon" style="display: none;">&#9432;</span>
      </div>
    </div>
    <button id="next-page">
      <span class="icon">></span>
      <span class="text">Next</span>
    </button>
    <span class="spacer"></span>
    <button id="zoom-out" class="zoom-button">-</button>
    <span id="zoom-level" class="zoom-level-display">100%</span>
    <button id="zoom-in" class="zoom-button">+</button>
    <span class="spacer"></span>
    <button id="fullscreen-btn">
      <span class="icon">&#x2922;</span>
      <span class="text" style="display: none;">Full Screen</span>
    </button>
    
    <!-- Hamburger Menu Button -->
    <button id="menu-btn" class="menu-button" title="More Options">
      <span class="icon">‚ò∞</span>
    </button>
  </div>

  <!-- Modal Overlay Menu -->
  <div id="pdf-menu-overlay" class="pdf-menu-overlay" style="display: none;">
    <div class="pdf-menu-modal">
      <div class="menu-header">
        <h3 class="menu-title">üìñ PDF Viewer Options</h3>
        <button id="menu-close-btn" class="menu-close-btn">&times;</button>
      </div>
      
      <div class="menu-content">
        <div class="menu-section">
          <h4 class="menu-section-title">üìñ Reading Mode</h4>
          <div class="menu-options">
            <label class="menu-option">
              <input type="radio" name="reading-mode" value="read" checked>
              <span class="option-icon">üìñ</span>
              <span class="option-text">Read Only</span>
            </label>
            <label class="menu-option">
              <input type="radio" name="reading-mode" value="audio">
              <span class="option-icon">üîä</span>
              <span class="option-text">Audio Mode</span>
            </label>
          </div>
        </div>

        <!-- TTS Controls Section -->
        <div id="tts-menu-section" class="menu-section" style="display: none;">
          <h4 class="menu-section-title">üéµ Audio Controls</h4>
          <div class="menu-controls">
            <div class="control-row">
              <button id="tts-play-pause" class="menu-control-btn">
                <span class="icon">‚ñ∂Ô∏è</span>
                <span class="text">Play</span>
              </button>
              <button id="tts-stop" class="menu-control-btn">
                <span class="icon">‚èπÔ∏è</span>
                <span class="text">Stop</span>
              </button>
            </div>
            <div class="control-row">
              <label class="control-label">üé§ Voice:</label>
              <select id="voice-selector" class="menu-select">
                <option value="">Default Voice</option>
              </select>
            </div>
            <div class="control-row">
              <label class="control-label">‚ö° Speed:</label>
              <select id="speed-selector" class="menu-select">
                <option value="0.6">0.6x (Very Slow)</option>
                <option value="0.75">0.75x (Slow)</option>
                <option value="0.9" selected>0.9x (Natural)</option>
                <option value="1.0">1.0x (Normal)</option>
                <option value="1.1">1.1x (Slightly Fast)</option>
                <option value="1.25">1.25x (Fast)</option>
                <option value="1.5">1.5x (Very Fast)</option>
              </select>
            </div>
            <div class="control-row">
              <label class="control-label">üéµ Pitch:</label>
              <select id="pitch-selector" class="menu-select">
                <option value="0.8">0.8 (Lower)</option>
                <option value="0.9">0.9 (Slightly Lower)</option>
                <option value="1.0" selected>1.0 (Normal)</option>
                <option value="1.1">1.1 (Slightly Higher)</option>
                <option value="1.2">1.2 (Higher)</option>
              </select>
            </div>
            <div class="control-row">
              <label class="menu-option">
                <input type="checkbox" id="auto-advance">
                <span class="option-text">üîÑ Auto-advance pages</span>
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- TTS Status Display -->
  <div id="tts-status" class="tts-status" style="display: none;">
    <div class="status-message"></div>
  </div>
</div>

<script define:vars={{ pdfUrl, pdfjsWorkerSrc }}>
  // Global variables
  let currentPdfDoc = null;
  let currentPageNum = 1;
  let currentScale = 1.5;
  let totalPages = 0;
  let ttsManager = null;
  let currentPageText = '';
  let autoAdvance = false;
  let isInitialized = false;

  // Cleanup function to prevent multiple initializations
  function cleanup() {
    if (currentPdfDoc) {
      console.log('Cleaning up existing PDF document');
      currentPdfDoc = null;
    }
    currentPageNum = 1;
    totalPages = 0;
    currentPageText = '';
    isInitialized = false;
  }

  // Initialize PDF and TTS
  async function initializePdfViewer() {
    if (isInitialized) {
      console.log('PDF viewer already initialized, skipping...');
      return;
    }
    
    try {
      console.log('üöÄ Starting PDF viewer initialization...');
      
      // Wait for DOM to be ready with multiple checks
      await waitForDOMReady();
      
      // Wait for required elements to be available
      await waitForRequiredElements();
      
      // Initialize PDF
      await loadPdf();
      
      // Initialize TTS
      await initializeTTS();
      
      // Setup event listeners
      setupEventListeners();
      
      console.log('‚úÖ PDF viewer initialization complete');
      isInitialized = true;
      
    } catch (error) {
      console.error('‚ùå Initialization failed:', error);
      const canvasWrapper = document.querySelector('.canvas-wrapper');
      if (canvasWrapper) {
        canvasWrapper.innerHTML = `<div style="padding: 20px; text-align: center; color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px;">
          <h3>‚ùå PDF Viewer Initialization Failed</h3>
          <p>Error: ${error.message}</p>
          <p>Please refresh the page to try again.</p>
        </div>`;
      }
    }
  }

  async function waitForDOMReady() {
    if (document.readyState === 'loading') {
      console.log('Waiting for DOM to be ready...');
      await new Promise(resolve => {
        document.addEventListener('DOMContentLoaded', resolve);
      });
    }
    console.log('DOM is ready');
  }

  async function waitForRequiredElements() {
    const requiredSelectors = [
      '.canvas-wrapper',
      '#page-num-display',
      '#page-count-display',
      '#prev-page',
      '#next-page'
    ];
    
    const maxWaitTime = 5000; // 5 seconds max wait
    const checkInterval = 100; // Check every 100ms
    let waitTime = 0;
    
    while (waitTime < maxWaitTime) {
      const missingElements = requiredSelectors.filter(selector => !document.querySelector(selector));
      
      if (missingElements.length === 0) {
        console.log('All required elements found');
        return;
      }
      
      console.log(`Waiting for elements: ${missingElements.join(', ')}`);
      await new Promise(resolve => setTimeout(resolve, checkInterval));
      waitTime += checkInterval;
    }
    
    const stillMissing = requiredSelectors.filter(selector => !document.querySelector(selector));
    if (stillMissing.length > 0) {
      console.warn(`Some elements still missing after ${maxWaitTime}ms: ${stillMissing.join(', ')}`);
      // Continue anyway - some elements might be optional
    }
  }

  async function loadPdf() {
    console.log('Loading PDF:', pdfUrl);
    
    try {
      // Dynamically import pdfjs-dist
      const pdfjsLib = await import('/pdf.min.mjs');
      
      // Set worker source
      pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorkerSrc;
      console.log('PDF.js worker source set to:', pdfjsWorkerSrc);

      const loadingTask = pdfjsLib.getDocument(pdfUrl);
      currentPdfDoc = await loadingTask.promise;
      totalPages = currentPdfDoc.numPages;
      
      console.log(`PDF loaded successfully: ${totalPages} pages`);

      // Update page display
      const pageNumElement = document.getElementById('page-num-display');
      const pageCountElement = document.getElementById('page-count-display');
      
      console.log('Updating page display:', { currentPageNum, totalPages });
      
      if (pageCountElement) {
        pageCountElement.textContent = totalPages.toString();
        console.log('Set page count to:', totalPages);
      } else {
        console.warn('Page count element not found');
      }
      
      if (pageNumElement) {
        pageNumElement.textContent = currentPageNum.toString();
        console.log('Set current page to:', currentPageNum);
      } else {
        console.warn('Page number element not found');
      }

      // Set page input max value
      const pageInput = document.getElementById('page-input');
      if (pageInput) {
        pageInput.max = totalPages.toString();
        pageInput.min = "1";
      }

      // Load saved reading progress
      const savedPage = loadReadingProgress();
      if (savedPage && savedPage !== currentPageNum && savedPage <= totalPages) {
        currentPageNum = savedPage;
      }

      // Initial render
      await renderPage(currentPageNum);
      updateZoomLevelDisplay();
      
    } catch (error) {
      console.error('Failed to load PDF:', error);
      const canvasWrapper = document.querySelector('.canvas-wrapper');
      if (canvasWrapper) {
        canvasWrapper.innerHTML = `<div style="padding: 20px; text-align: center; color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px;">
          <h3>‚ùå Failed to load PDF</h3>
          <p>Error: ${error.message}</p>
          <p>PDF URL: ${pdfUrl}</p>
          <p>Please check that the PDF file exists and is accessible.</p>
        </div>`;
      }
    }
  }

  async function initializeTTS() {
    try {
      // Check if SimpleTtsManager is already loaded
      if (typeof window.SimpleTtsManager !== 'undefined') {
        console.log('SimpleTtsManager already loaded, using existing instance');
        try {
          ttsManager = new SimpleTtsManager();
          const success = await ttsManager.initialize();
          
          if (success || ttsManager.isInitialized) {
            setupTTSControls();
            showTTSControls();
          } else {
            console.warn('TTS initialization returned false, showing unavailable');
            showTTSUnavailable('unavailable');
          }
        } catch (error) {
          console.error('Error creating TTS manager:', error);
          showTTSUnavailable('unavailable');
        }
        return;
      }

      // Load SimpleTtsManager script only if not already loaded
      const existingScript = document.querySelector('script[src="/SimpleTtsManager.js"]');
      if (existingScript) {
        console.log('SimpleTtsManager script already exists, waiting for load...');
        // Wait for existing script to load
        if (typeof window.SimpleTtsManager !== 'undefined') {
          try {
            ttsManager = new SimpleTtsManager();
            const success = await ttsManager.initialize();
            
            if (success || ttsManager.isInitialized) {
              setupTTSControls();
              showTTSControls();
            } else {
              console.warn('TTS initialization returned false, showing unavailable');
              showTTSUnavailable('unavailable');
            }
          } catch (error) {
            console.error('Error with existing TTS script:', error);
            showTTSUnavailable('unavailable');
          }
        }
        return;
      }

      console.log('Loading SimpleTtsManager script...');
      const script = document.createElement('script');
      script.src = '/SimpleTtsManager.js';
      script.onload = async () => {
        console.log('SimpleTtsManager script loaded successfully');
        try {
          ttsManager = new SimpleTtsManager();
          const success = await ttsManager.initialize();
          
          if (success || ttsManager.isInitialized) {
            setupTTSControls();
            showTTSControls();
          } else {
            console.warn('TTS initialization returned false, showing unavailable');
            showTTSUnavailable('unavailable');
          }
        } catch (error) {
          console.error('Error initializing TTS after script load:', error);
          showTTSUnavailable('unavailable');
        }
      };
      script.onerror = () => {
        console.error('Failed to load SimpleTtsManager script');
        showTTSUnavailable('unavailable');
      };
      document.head.appendChild(script);
      
    } catch (error) {
      console.error('TTS initialization failed:', error);
      showTTSUnavailable('unavailable');
    }
  }

  function setupTTSControls() {
    // Check if TTS manager is properly initialized
    if (!ttsManager || !ttsManager.isInitialized) {
      console.error('TTS manager not properly initialized');
      showTTSUnavailable('unavailable');
      return;
    }

    // Populate voice selector with quality-ranked voices
    const voiceSelector = document.getElementById('voice-selector');
    const allVoices = ttsManager.getVoices();
    
    voiceSelector.innerHTML = '<option value="">Best Available Voice</option>';
    
    // Check if getBestVoices method exists (for backward compatibility)
    let bestVoices = [];
    if (typeof ttsManager.getBestVoices === 'function') {
      bestVoices = ttsManager.getBestVoices();
    }
    
    // Add best voices first if available
    if (bestVoices.length > 0) {
      const optgroup = document.createElement('optgroup');
      optgroup.label = 'Recommended Voices';
      bestVoices.slice(0, 5).forEach((voice, index) => {
        const option = document.createElement('option');
        option.value = allVoices.indexOf(voice);
        option.textContent = `${voice.name} (${voice.lang})`;
        optgroup.appendChild(option);
      });
      voiceSelector.appendChild(optgroup);
    }
    
    // Add all voices (or remaining voices if we have best voices)
    const remainingVoices = bestVoices.length > 0
      ? allVoices.filter(voice => !bestVoices.slice(0, 5).includes(voice))
      : allVoices;
      
    if (remainingVoices.length > 0) {
      const optgroup = document.createElement('optgroup');
      optgroup.label = bestVoices.length > 0 ? 'Other Voices' : 'Available Voices';
      remainingVoices.forEach((voice, index) => {
        const option = document.createElement('option');
        option.value = allVoices.indexOf(voice);
        option.textContent = `${voice.name} (${voice.lang})`;
        optgroup.appendChild(option);
      });
      voiceSelector.appendChild(optgroup);
    }

    // Setup event listeners
    document.getElementById('tts-play-pause').addEventListener('click', toggleTTS);
    document.getElementById('tts-stop').addEventListener('click', stopTTS);
    document.getElementById('auto-advance').addEventListener('change', (e) => {
      autoAdvance = e.target.checked;
    });

    // TTS status updates
    ttsManager.onStatusChange = updateTTSStatus;
    ttsManager.onEnd = handleTTSEnd;
    
    console.log('TTS controls setup complete with', allVoices.length, 'voices available');
  }

  async function toggleTTS() {
    if (!ttsManager) return;

    const status = ttsManager.getStatus();
    
    if (status.isPlaying && !status.isPaused) {
      ttsManager.pause();
    } else if (status.isPaused) {
      ttsManager.resume();
    } else {
      await startTTS();
    }
  }

  async function startTTS() {
    if (!currentPageText) {
      currentPageText = await extractPageText(currentPageNum);
    }

    if (!currentPageText) {
      showTTSStatus('No text found on this page', 'warning');
      return;
    }

    try {
      const voiceSelector = document.getElementById('voice-selector');
      const speedSelector = document.getElementById('speed-selector');
      const pitchSelector = document.getElementById('pitch-selector');
      
      const selectedVoiceIndex = voiceSelector.value;
      const selectedVoice = selectedVoiceIndex ? ttsManager.getVoices()[selectedVoiceIndex] : null;
      const rate = parseFloat(speedSelector.value) || 0.9;
      const pitch = parseFloat(pitchSelector.value) || 1.0;

      // Use chunked speech for better flow
      await speakInChunks(currentPageText, {
        voice: selectedVoice,
        rate: rate,
        pitch: pitch
      });

    } catch (error) {
      console.error('TTS failed:', error);
      
      // Check if this is a synthesis-failed error and show appropriate message
      if (error.message.includes('synthesis-failed')) {
        showTTSUnavailable('synthesis-failed');
      } else {
        showTTSStatus(`Speech failed: ${error.message}`, 'error');
      }
    }
  }

  // Text Chunking for Better Speech
  function chunkTextForTTS(text, maxLength = 150) {
    // Split by sentences for natural pauses
    const sentences = text.match(/[^\.!?]+[\.!?]+/g) || [text];
    const chunks = [];
    let currentChunk = '';
    
    for (const sentence of sentences) {
      const trimmedSentence = sentence.trim();
      if (currentChunk.length + trimmedSentence.length <= maxLength) {
        currentChunk += (currentChunk ? ' ' : '') + trimmedSentence;
      } else {
        if (currentChunk) chunks.push(currentChunk.trim());
        currentChunk = trimmedSentence;
      }
    }
    
    if (currentChunk) chunks.push(currentChunk.trim());
    
    // Filter out empty chunks
    return chunks.filter(chunk => chunk.length > 0);
  }

  async function speakInChunks(text, options = {}) {
    const chunks = chunkTextForTTS(text);
    
    for (let i = 0; i < chunks.length; i++) {
      // Check if TTS was stopped
      if (!ttsManager.getStatus().isPlaying && i > 0) {
        break;
      }
      
      await ttsManager.speak(chunks[i], options);
      
      // Reduced pause between chunks for smoother flow
      if (i < chunks.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  }

  function stopTTS() {
    if (ttsManager) {
      ttsManager.stop();
    }
  }

  async function extractPageText(pageNum) {
    if (!currentPdfDoc) return '';
    
    try {
      const page = await currentPdfDoc.getPage(pageNum);
      const textContent = await page.getTextContent();
      
      return textContent.items
        .filter(item => item.str.trim())
        .map(item => item.str)
        .join(' ')
        .replace(/\s+/g, ' ')
        .trim();
        
    } catch (error) {
      console.error('Text extraction failed:', error);
      return '';
    }
  }

  function updateTTSStatus(status) {
    const playPauseBtn = document.getElementById('tts-play-pause');
    if (!playPauseBtn) return;

    if (status.isPlaying && !status.isPaused) {
      playPauseBtn.innerHTML = '<span class="icon">‚è∏Ô∏è</span><span class="text">Pause</span>';
    } else if (status.isPaused) {
      playPauseBtn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span><span class="text">Resume</span>';
    } else {
      playPauseBtn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span><span class="text">Play</span>';
    }
  }

  function handleTTSEnd() {
    if (autoAdvance && currentPageNum < totalPages) {
      setTimeout(async () => {
        await renderPage(currentPageNum + 1);
        currentPageText = ''; // Reset for new page
        await startTTS(); // Auto-start on new page
      }, 1000);
    }
  }

  function showTTSControls() {
    const ttsSection = document.getElementById('tts-menu-section');
    if (ttsSection) {
      ttsSection.style.display = 'block';
    }
  }

  function showTTSUnavailable(errorType = 'unavailable') {
    const statusDiv = document.getElementById('tts-status');
    if (statusDiv) {
      const userAgent = navigator.userAgent.toLowerCase();
      const platform = navigator.platform.toLowerCase();
      let message = 'üìñ Text-to-speech not available.';
      
      if (userAgent.includes('linux')) {
        if (errorType === 'synthesis-failed') {
          message = `
            üîä Text-to-speech failed on this Linux system.<br>
            <strong>Try these solutions:</strong><br>
            ‚Ä¢ <strong>Use Firefox instead of Chrome/Brave</strong> (works much better on Linux)<br>
            ‚Ä¢ Install speech-dispatcher: <code>sudo apt install speech-dispatcher</code><br>
            ‚Ä¢ Restart your browser after installing speech-dispatcher<br>
            ‚Ä¢ Use <a href="https://ttsreader.com" target="_blank">TTSReader.com</a> as alternative<br>
            <em>Note: Firefox typically has better TTS support on Linux than Chrome/Brave.</em>
          `;
        } else {
          message = `
            üìñ Text-to-speech may not be available on this Linux system.<br>
            <strong>Try these solutions:</strong><br>
            ‚Ä¢ <strong>Use Firefox instead of Chrome/Brave</strong> (works much better on Linux)<br>
            ‚Ä¢ Install speech-dispatcher: <code>sudo apt install speech-dispatcher</code><br>
            ‚Ä¢ Use <a href="https://ttsreader.com" target="_blank">TTSReader.com</a> as alternative<br>
            <em>Note: Voice quality will be much better on Mac, Windows, or Android devices.</em>
          `;
        }
      } else if (userAgent.includes('mac') || platform.includes('mac')) {
        message = `
          üìñ Text-to-speech not available.<br>
          <strong>Mac usually has excellent voice quality!</strong><br>
          ‚Ä¢ Check Safari or Chrome browser settings<br>
          ‚Ä¢ Try <a href="https://ttsreader.com" target="_blank">TTSReader.com</a> as alternative
        `;
      } else if (userAgent.includes('win') || platform.includes('win')) {
        message = `
          üìñ Text-to-speech not available.<br>
          <strong>Windows has good voice quality!</strong><br>
          ‚Ä¢ Check browser permissions for microphone/speech<br>
          ‚Ä¢ Try <a href="https://ttsreader.com" target="_blank">TTSReader.com</a> as alternative
        `;
      } else if (userAgent.includes('android')) {
        message = `
          üìñ Text-to-speech not available.<br>
          <strong>Android usually has good Google voices!</strong><br>
          ‚Ä¢ Check Chrome browser settings<br>
          ‚Ä¢ Try <a href="https://ttsreader.com" target="_blank">TTSReader.com</a> as alternative
        `;
      } else {
        message += ` <a href="https://ttsreader.com" target="_blank">Try TTSReader.com</a>`;
      }
      
      statusDiv.innerHTML = `<div class="status-message warning">${message}</div>`;
      statusDiv.style.display = 'block';
    }
  }

  function showTTSStatus(message, type = 'info') {
    const statusDiv = document.getElementById('tts-status');
    if (statusDiv) {
      statusDiv.innerHTML = `<div class="status-message ${type}">${message}</div>`;
      statusDiv.style.display = 'block';
      
      if (type !== 'error') {
        setTimeout(() => {
          statusDiv.style.display = 'none';
        }, 3000);
      }
    }
  }

  // PDF Rendering Functions
  async function renderPage(num, scale = null) {
    if (!currentPdfDoc) {
      console.error('Cannot render page: PDF document not loaded');
      return;
    }
    
    if (num < 1 || num > totalPages) {
      console.error(`Invalid page number: ${num}. Valid range: 1-${totalPages}`);
      return;
    }
    
    const useScale = scale || currentScale;
    console.log(`Rendering page ${num} of ${totalPages} at scale ${useScale}`);
    
    try {
      const page = await currentPdfDoc.getPage(num);
      const viewport = page.getViewport({ scale: useScale });

      // Get canvas container
      const canvasWrapper = document.querySelector('.canvas-wrapper');
      if (!canvasWrapper) {
        console.error('Canvas wrapper not found');
        return;
      }

      // Create fresh canvas
      const oldCanvas = document.getElementById('pdf-canvas');
      if (oldCanvas) {
        oldCanvas.remove();
      }
      
      const canvas = document.createElement('canvas');
      canvas.id = 'pdf-canvas';
      
      // Set canvas dimensions properly
      const devicePixelRatio = window.devicePixelRatio || 1;
      canvas.width = viewport.width * devicePixelRatio;
      canvas.height = viewport.height * devicePixelRatio;
      canvas.style.width = viewport.width + 'px';
      canvas.style.height = viewport.height + 'px';
      
      canvasWrapper.appendChild(canvas);

      const ctx = canvas.getContext('2d');
      
      // Scale context for high DPI displays
      ctx.scale(devicePixelRatio, devicePixelRatio);
      
      const renderContext = {
        canvasContext: ctx,
        viewport: viewport,
      };
      
      console.log(`Starting render for page ${num}...`);
      await page.render(renderContext).promise;
      console.log(`‚úÖ Successfully rendered page ${num}`);
      
      // Update state
      currentPageNum = num;
      currentScale = useScale;
      currentPageText = ''; // Reset text for new page
      
      // Update UI
      const pageNumElement = document.getElementById('page-num-display');
      if (pageNumElement) {
        pageNumElement.textContent = num.toString();
        console.log('Updated page display to:', num);
      } else {
        console.warn('Page number element not found during render');
      }

      const prevButton = document.getElementById('prev-page');
      const nextButton = document.getElementById('next-page');
      if (prevButton) prevButton.disabled = num <= 1;
      if (nextButton) nextButton.disabled = num >= totalPages;
      
      // Save reading progress
      saveReadingProgress();
      
      console.log(`Successfully rendered page ${num}`);
      
    } catch (error) {
      console.error('Error rendering page:', error);
      const canvasWrapper = document.querySelector('.canvas-wrapper');
      if (canvasWrapper) {
        canvasWrapper.innerHTML = `<div style="padding: 20px; text-align: center; color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px;">
          <h3>‚ùå Failed to render page ${num}</h3>
          <p>Error: ${error.message}</p>
        </div>`;
      }
    }
  }

  function updateZoomLevelDisplay() {
    const zoomLevelElement = document.getElementById('zoom-level');
    if (zoomLevelElement) {
      zoomLevelElement.textContent = `${Math.round(currentScale * 100)}%`;
    }
  }

  // Reading Progress Functions
  function saveReadingProgress() {
    const progress = {
      pdfUrl: pdfUrl,
      currentPage: currentPageNum,
      timestamp: Date.now()
    };
    localStorage.setItem('pdfReadingProgress', JSON.stringify(progress));
  }

  function loadReadingProgress() {
    try {
      const saved = localStorage.getItem('pdfReadingProgress');
      if (saved) {
        const progress = JSON.parse(saved);
        if (progress.pdfUrl === pdfUrl) {
          return progress.currentPage;
        }
      }
    } catch (error) {
      console.error('Failed to load reading progress:', error);
    }
    return 1;
  }

  // Event Listeners Setup
  function setupEventListeners() {
    console.log('üîß Setting up event listeners...');
    
    // Navigation buttons
    const prevButton = document.getElementById('prev-page');
    const nextButton = document.getElementById('next-page');
    
    console.log('Navigation buttons found:', { prevButton: !!prevButton, nextButton: !!nextButton });
    
    if (prevButton) {
      prevButton.addEventListener('click', async () => {
        console.log('Previous button clicked');
        if (currentPageNum > 1) {
          await renderPage(currentPageNum - 1);
        }
      });
    } else {
      console.warn('Previous button not found');
    }

    if (nextButton) {
      nextButton.addEventListener('click', async () => {
        console.log('Next button clicked');
        if (currentPageNum < totalPages) {
          await renderPage(currentPageNum + 1);
        }
      });
    } else {
      console.warn('Next button not found');
    }

    // Zoom controls
    const zoomInButton = document.getElementById('zoom-in');
    const zoomOutButton = document.getElementById('zoom-out');
    
    console.log('Zoom buttons found:', { zoomInButton: !!zoomInButton, zoomOutButton: !!zoomOutButton });
    
    if (zoomInButton) {
      zoomInButton.addEventListener('click', async () => {
        console.log('Zoom in button clicked');
        const newScale = currentScale + 0.25;
        await renderPage(currentPageNum, newScale);
        updateZoomLevelDisplay();
      });
    } else {
      console.warn('Zoom in button not found');
    }

    if (zoomOutButton) {
      zoomOutButton.addEventListener('click', async () => {
        console.log('Zoom out button clicked');
        if (currentScale > 0.25) {
          const newScale = currentScale - 0.25;
          await renderPage(currentPageNum, newScale);
          updateZoomLevelDisplay();
        }
      });
    } else {
      console.warn('Zoom out button not found');
    }

    // Fullscreen
    const fullscreenButton = document.getElementById('fullscreen-btn');
    const pdfViewerContainer = document.getElementById('pdf-viewer-container');
    
    console.log('Other elements found:', { fullscreenButton: !!fullscreenButton, pdfViewerContainer: !!pdfViewerContainer });
    
    if (fullscreenButton && pdfViewerContainer) {
      fullscreenButton.addEventListener('click', () => {
        console.log('Fullscreen button clicked');
        if (!document.fullscreenElement) {
          pdfViewerContainer.requestFullscreen().catch(err => {
            console.log('Fullscreen request failed:', err);
          });
        } else {
          document.exitFullscreen().catch(err => {
            console.log('Exit fullscreen failed:', err);
          });
        }
      });
    } else {
      console.warn('Fullscreen button or container not found');
    }

    // Page navigation
    setupPageNavigation();
    
    // Menu functionality
    setupMenuControls();
    
    // Reading mode controls
    setupReadingModeControls();
    
    // Keyboard shortcuts
    setupKeyboardShortcuts();
  }

  function setupPageNavigation() {
    const pageIndicator = document.getElementById('page-indicator');
    const pageNavigationGroup = document.getElementById('page-navigation-group');
    const pageInput = document.getElementById('page-input');
    const gotoPageBtn = document.getElementById('goto-page-btn');

    if (pageIndicator) {
      pageIndicator.addEventListener('click', () => {
        if (pageNavigationGroup) {
          pageNavigationGroup.style.display = 'block';
        }
        if (pageIndicator) {
          pageIndicator.style.display = 'none';
        }
        if (pageInput) {
          pageInput.value = currentPageNum.toString();
          pageInput.focus();
          pageInput.select();
        }
      });
    }

    async function handleGoToPage() {
      if (!pageInput) return;
      const newPageNum = parseInt(pageInput.value, 10);
      if (!isNaN(newPageNum) && newPageNum >= 1 && newPageNum <= totalPages) {
        if (newPageNum !== currentPageNum) {
          await renderPage(newPageNum);
        }
        switchToPageDisplayView();
      } else {
        pageInput.focus();
        pageInput.select();
      }
    }

    function switchToPageDisplayView() {
      if (pageNavigationGroup) {
        pageNavigationGroup.style.display = 'none';
      }
      if (pageIndicator) {
        pageIndicator.style.display = 'inline-flex';
      }
    }

    if (gotoPageBtn) {
      gotoPageBtn.addEventListener('click', handleGoToPage);
    }
    
    if (pageInput) {
      pageInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          handleGoToPage();
        }
      });
    }
  }

  function setupMenuControls() {
    const menuBtn = document.getElementById('menu-btn');
    const menuOverlay = document.getElementById('pdf-menu-overlay');
    const menuCloseBtn = document.getElementById('menu-close-btn');

    if (menuBtn && menuOverlay) {
      menuBtn.addEventListener('click', () => {
        menuOverlay.style.display = 'flex';
      });
    }

    if (menuCloseBtn && menuOverlay) {
      menuCloseBtn.addEventListener('click', () => {
        menuOverlay.style.display = 'none';
      });
    }

    if (menuOverlay) {
      menuOverlay.addEventListener('click', (e) => {
        if (e.target === menuOverlay) {
          menuOverlay.style.display = 'none';
        }
      });
    }
  }

  function setupReadingModeControls() {
    const readingModeInputs = document.querySelectorAll('input[name="reading-mode"]');
    const ttsMenuSection = document.getElementById('tts-menu-section');

    readingModeInputs.forEach(input => {
      input.addEventListener('change', (e) => {
        const mode = e.target.value;
        
        if (mode === 'audio') {
          if (ttsMenuSection) {
            ttsMenuSection.style.display = 'block';
          }
        } else {
          if (ttsMenuSection) {
            ttsMenuSection.style.display = 'none';
          }
          // Stop TTS if switching away from audio mode
          stopTTS();
        }
      });
    });
  }

  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (event) => {
      // Only handle shortcuts when not typing in inputs
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        return;
      }

      if (event.ctrlKey || event.metaKey) {
        switch (event.key) {
          case ' ': // Ctrl/Cmd + Space - Toggle TTS
            event.preventDefault();
            toggleTTS();
            break;
          case 'ArrowRight': // Ctrl/Cmd + Right - Next page
            event.preventDefault();
            if (currentPageNum < totalPages) {
              renderPage(currentPageNum + 1);
            }
            break;
          case 'ArrowLeft': // Ctrl/Cmd + Left - Previous page
            event.preventDefault();
            if (currentPageNum > 1) {
              renderPage(currentPageNum - 1);
            }
            break;
        }
      }
    });
  }

  // Initialize with multiple fallbacks and better timing
  let initializationAttempted = false;
  
  function attemptInitialization() {
    if (initializationAttempted) {
      console.log('Initialization already attempted, skipping...');
      return;
    }
    initializationAttempted = true;
    
    // Small delay to ensure all elements are rendered
    setTimeout(() => {
      initializePdfViewer();
    }, 100);
  }

  // Primary initialization
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attemptInitialization);
  } else if (document.readyState === 'interactive') {
    // DOM is ready but resources might still be loading
    attemptInitialization();
  } else {
    // DOM and resources are ready
    attemptInitialization();
  }
  
  // Fallback initialization on window load
  window.addEventListener('load', () => {
    if (!isInitialized && !currentPdfDoc) {
      console.log('Fallback initialization on window load');
      initializationAttempted = false; // Allow retry
      attemptInitialization();
    }
  });
  
  // Additional fallback with delay for problematic cases
  setTimeout(() => {
    if (!isInitialized && !currentPdfDoc) {
      console.log('Final fallback initialization after 2 seconds');
      initializationAttempted = false; // Allow retry
      attemptInitialization();
    }
  }, 2000);

  // Cleanup on page unload
  window.addEventListener('beforeunload', cleanup);
  
  // Cleanup on page hide (for mobile browsers)
  window.addEventListener('pagehide', cleanup);
</script>

<style>
  .pdf-viewer-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: transparent;
  }

  .canvas-wrapper {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    overflow: auto;
    padding: 0;
    background: transparent;
    min-height: 0; /* Allow flex item to shrink */
  }

  #pdf-canvas {
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    background: white;
    display: block;
    margin: auto;
    max-width: none;
    max-height: none;
  }

  .pdf-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 20px;
    background: white;
    border-top: 1px solid #ddd;
    flex-wrap: wrap;
  }

  .pdf-controls button {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
    cursor: pointer;
    font-size: 14px;
  }

  .pdf-controls button:hover {
    background: #f0f0f0;
  }

  .pdf-controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .page-indicator {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }

  .page-input-container {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  #page-input {
    width: 60px;
    padding: 4px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    text-align: center;
  }

  .zoom-level-display {
    padding: 8px 12px;
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    min-width: 50px;
    text-align: center;
  }

  .spacer {
    flex: 1;
  }

  .menu-button {
    font-size: 18px !important;
  }

  /* Menu Overlay Styles */
  .pdf-menu-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .pdf-menu-modal {
    background: white;
    border-radius: 8px;
    padding: 20px;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }

  .menu-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
  }

  .menu-title {
    margin: 0;
    font-size: 18px;
  }

  .menu-close-btn {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .menu-section {
    margin-bottom: 20px;
  }

  .menu-section-title {
    font-size: 16px;
    margin: 0 0 10px 0;
    color: #333;
  }

  .menu-options {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .menu-option {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    padding: 8px;
    border-radius: 4px;
    transition: background-color 0.2s;
  }

  .menu-option:hover {
    background: #f8f9fa;
  }

  .option-icon {
    font-size: 16px;
  }

  .option-text {
    font-size: 14px;
  }

  .menu-controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .control-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .control-label {
    font-weight: 500;
    min-width: 60px;
    font-size: 14px;
  }

  .menu-control-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    border: none;
    border-radius: 6px;
    background: #f8f9fa;
    color: #495057;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 14px;
  }

  .menu-control-btn:hover {
    background: #e9ecef;
    transform: translateY(-1px);
  }

  .menu-control-btn:active {
    transform: translateY(0);
  }

  .menu-control-btn .icon {
    font-size: 16px;
  }

  .menu-select {
    flex: 1;
    padding: 6px 10px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    background: white;
    font-size: 14px;
  }

  /* TTS Status Styles */
  .tts-status {
    margin: 10px 0;
    padding: 12px;
    border-radius: 8px;
    font-size: 14px;
  }

  .status-message {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-message.info {
    background: #d1ecf1;
    border: 1px solid #bee5eb;
    color: #0c5460;
  }

  .status-message.warning {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    color: #856404;
  }

  .status-message.error {
    background: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #721c24;
  }

  .status-message a {
    color: inherit;
    text-decoration: underline;
  }

  .status-message code {
    background: rgba(0, 0, 0, 0.1);
    padding: 2px 4px;
    border-radius: 3px;
    font-family: monospace;
    font-size: 12px;
  }

  .status-message strong {
    font-weight: 600;
  }

  @media (max-width: 768px) {
    .pdf-controls {
      padding: 8px 10px;
      gap: 5px;
    }
    
    .pdf-controls button {
      padding: 6px 8px;
      font-size: 12px;
    }
    
    .pdf-controls .text {
      display: none;
    }
    
    .pdf-menu-modal {
      width: 95%;
      padding: 15px;
    }
  }
</style>