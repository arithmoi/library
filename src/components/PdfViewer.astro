---
// src/components/PdfViewer.astro
export interface Props {
  pdfUrl: string;
}

const { pdfUrl } = Astro.props;

// Construct the worker URL. This is crucial for PDF.js.
// It assumes pdf.worker.min.mjs is available relative to the built assets.
// Astro typically places files from node_modules in /node_modules/ after build,
// but for development, we might need a more direct path or ensure it's copied.
// For now, let's aim for a path that works in production.
// We'll need to ensure the worker file is correctly served.
// This path assumes pdf.worker.min.mjs has been copied to the public directory.
const pdfjsWorkerSrc = `/pdf.worker.min.mjs`;

---
<div id="pdf-viewer-container" class="pdf-viewer-container">
  <div class="canvas-wrapper">
    <canvas id="pdf-canvas"></canvas>
  </div>
  <div class="pdf-controls">
    <button id="prev-page">
      <span class="icon"><</span>
      <span class="text">Previous</span>
    </button>
    <div id="page-indicator" class="page-indicator">
      <span id="page-num-display"></span>&nbsp;/&nbsp;<span id="page-count-display"></span>
    </div>
    <div id="page-navigation-group" style="display: none;">
      <div id="page-input-container" class="page-input-container">
        <input type="number" id="page-input" min="1" />
        <button id="goto-page-btn">Go</button>
        <span id="page-input-error-icon" class="page-input-error-icon" style="display: none;">&#9432;</span>
      </div>
    </div>
    <button id="next-page">
      <span class="icon">></span>
      <span class="text">Next</span>
    </button>
    <span class="spacer"></span>
    <button id="zoom-out" class="zoom-button">-</button>
    <span id="zoom-level" class="zoom-level-display">100%</span>
    <button id="zoom-in" class="zoom-button">+</button>
    <span class="spacer"></span>
    <button id="fullscreen-btn">
      <span class="icon">&#x2922;</span> <!-- Unicode for fullscreen icon â¤¢ -->
      <span class="text" style="display: none;">Full Screen</span> <!-- Text always hidden -->
    </button>
  </div>
</div>

<script define:vars={{ pdfUrl, pdfjsWorkerSrc }}>
  // Global variables to track current PDF state
  let currentPdfDoc = null;
  let currentPageNum = 1;
  let currentScale = 1.5;
  let totalPages = 0;
  let isRendering = false;
  let renderTask = null;
  let renderQueue = [];
  let isProcessingQueue = false;

  // Cleanup function to remove existing event listeners
  function cleanupPdfViewer() {
    // Cancel any ongoing render task
    if (renderTask) {
      try {
        renderTask.cancel();
      } catch (e) {
        console.log('Render task already completed or cancelled');
      }
      renderTask = null;
    }
    
    // Clear render queue
    renderQueue = [];
    isProcessingQueue = false;
    
    // Remove click outside handler
    if (window.pdfClickOutsideHandler) {
      document.removeEventListener('click', window.pdfClickOutsideHandler, true);
      window.pdfClickOutsideHandler = null;
    }
    
    // Clear canvas
    const canvas = document.getElementById('pdf-canvas');
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }
    
    // Reset global state
    currentPdfDoc = null;
    currentPageNum = 1;
    currentScale = 1.5;
    totalPages = 0;
    isRendering = false;
    window.currentPdfUrl = null;
  }

  async function initializePdfViewer() {
    try {
      // Check if container exists
      const container = document.getElementById('pdf-viewer-container');
      if (!container) {
        console.error('PDF container not found');
        return;
      }

      // Force cleanup and reload for every initialization to ensure clean state
      console.log(`Initializing PDF viewer with URL: ${pdfUrl}`);
      console.log(`Previous URL was: ${window.currentPdfUrl}`);
      
      // Always cleanup to ensure clean state
      cleanupPdfViewer();
      
      // Set current URL immediately to prevent race conditions
      window.currentPdfUrl = pdfUrl;
      console.log('Loading PDF:', pdfUrl);

      // Dynamically import pdfjs-dist to keep initial load small
      const pdfjsLib = await import('/pdf.min.mjs');
      if (!pdfjsLib.GlobalWorkerOptions.workerSrc && pdfjsWorkerSrc) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorkerSrc;
      }

      const loadingTask = pdfjsLib.getDocument(pdfUrl);
      currentPdfDoc = await loadingTask.promise;
      totalPages = currentPdfDoc.numPages;
      
      console.log(`PDF loaded successfully: ${totalPages} pages`);

      // Get DOM elements
      const pageNumElement = document.getElementById('page-num-display');
      const pageCountElement = document.getElementById('page-count-display');
      const pageIndicator = document.getElementById('page-indicator');
      const pageNavigationGroup = document.getElementById('page-navigation-group');
      const pageInputContainer = document.getElementById('page-input-container');
      const pageInput = document.getElementById('page-input');
      const gotoPageBtn = document.getElementById('goto-page-btn');
      const pageInputErrorIcon = document.getElementById('page-input-error-icon');
      const prevButton = document.getElementById('prev-page');
      const nextButton = document.getElementById('next-page');
      const zoomOutButton = document.getElementById('zoom-out');
      const zoomInButton = document.getElementById('zoom-in');
      const zoomLevelElement = document.getElementById('zoom-level');
      const fullscreenButton = document.getElementById('fullscreen-btn');
      const pdfViewerContainer = document.getElementById('pdf-viewer-container');

      // Initialize page display with correct total pages
      if (pageCountElement) {
        pageCountElement.textContent = totalPages.toString();
        console.log(`Set page count display to: ${totalPages}`);
      } else {
        console.error('Page count element not found');
      }
      
      if (pageNumElement) {
        pageNumElement.textContent = currentPageNum.toString();
        console.log(`Set current page display to: ${currentPageNum}`);
      } else {
        console.error('Page number element not found');
      }
      
      // Set page input max value
      if (pageInput) {
        pageInput.max = totalPages.toString();
        pageInput.min = "1";
      }

      function updateZoomLevelDisplay() {
        if (zoomLevelElement) {
          zoomLevelElement.textContent = `${Math.round(currentScale * 100)}%`;
        }
      }

      // Queue-based rendering system to prevent canvas conflicts
      async function queueRender(pageNum, scale = null) {
        return new Promise((resolve, reject) => {
          const renderRequest = {
            pageNum,
            scale: scale || currentScale,
            resolve,
            reject
          };
          
          renderQueue.push(renderRequest);
          processRenderQueue();
        });
      }

      async function processRenderQueue() {
        if (isProcessingQueue || renderQueue.length === 0) {
          return;
        }
        
        isProcessingQueue = true;
        
        while (renderQueue.length > 0) {
          const request = renderQueue.shift();
          
          try {
            await renderPageInternal(request.pageNum, request.scale);
            request.resolve();
          } catch (error) {
            request.reject(error);
          }
        }
        
        isProcessingQueue = false;
      }

      async function renderPageInternal(num, scale) {
        if (!currentPdfDoc) {
          throw new Error('Cannot render page: missing PDF document');
        }
        
        if (num < 1 || num > totalPages) {
          throw new Error(`Invalid page number: ${num}. Valid range: 1-${totalPages}`);
        }
        
        // Cancel any ongoing render operation
        if (renderTask) {
          try {
            renderTask.cancel();
          } catch (e) {
            console.log('Previous render task already completed');
          }
          renderTask = null;
        }
        
        console.log(`Rendering page ${num} of ${totalPages} at scale ${scale}`);
        
        const page = await currentPdfDoc.getPage(num);
        const viewport = page.getViewport({ scale });

        // Get the canvas container
        const canvasWrapper = document.querySelector('.canvas-wrapper');
        if (!canvasWrapper) {
          throw new Error('Canvas wrapper not found');
        }

        // Always create a fresh canvas to avoid conflicts
        const oldCanvas = document.getElementById('pdf-canvas');
        if (oldCanvas) {
          oldCanvas.remove();
        }
        
        const canvas = document.createElement('canvas');
        canvas.id = 'pdf-canvas';
        
        // Set canvas dimensions to match viewport
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        // Set the CSS display size of the canvas to match its drawing resolution
        canvas.style.width = viewport.width + 'px';
        canvas.style.height = viewport.height + 'px';
        
        // Add canvas to DOM
        canvasWrapper.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        
        const renderContext = {
          canvasContext: ctx,
          viewport: viewport,
        };
        
        // Store the render task so we can cancel it if needed
        renderTask = page.render(renderContext);
        await renderTask.promise;
        renderTask = null;
        
        // Update current page number and scale
        currentPageNum = num;
        currentScale = scale;
        
        // Update page display
        const currentPageNumElement = document.getElementById('page-num-display');
        if (currentPageNumElement) {
          currentPageNumElement.textContent = num.toString();
        }

        // Update button states
        const currentPrevButton = document.getElementById('prev-page');
        const currentNextButton = document.getElementById('next-page');
        if (currentPrevButton) {
          currentPrevButton.disabled = num <= 1;
        }
        if (currentNextButton) {
          currentNextButton.disabled = num >= totalPages;
        }
        
        console.log(`Successfully rendered page ${num}`);
      }

      // Public render function that uses the queue
      async function renderPage(num, scale = null) {
        try {
          await queueRender(num, scale);
        } catch (error) {
          if (error.name === 'RenderingCancelledException') {
            console.log('Render operation was cancelled');
          } else {
            console.error('Error rendering PDF page:', error);
            const container = document.getElementById('pdf-viewer-container');
            if (container) {
              const canvasWrapper = container.querySelector('.canvas-wrapper');
              if (canvasWrapper) {
                canvasWrapper.innerHTML = `<p>Error rendering page ${num}: ${error.message}</p>`;
              }
            }
          }
        }
      }

      // Add event listeners with null checks
      if (prevButton) {
        prevButton.addEventListener('click', async () => {
          if (currentPageNum <= 1) return;
          await renderPage(currentPageNum - 1);
        });
      }

      if (nextButton) {
        nextButton.addEventListener('click', async () => {
          if (currentPageNum >= totalPages) return;
          await renderPage(currentPageNum + 1);
        });
      }

      // Initial render
      await renderPage(currentPageNum);
      updateZoomLevelDisplay();

      if (zoomInButton) {
        zoomInButton.addEventListener('click', async () => {
          const newScale = currentScale + 0.25;
          await renderPage(currentPageNum, newScale);
          updateZoomLevelDisplay();
        });
      }

      if (zoomOutButton) {
        zoomOutButton.addEventListener('click', async () => {
          if (currentScale <= 0.25) return; // Minimum scale
          const newScale = currentScale - 0.25;
          await renderPage(currentPageNum, newScale);
          updateZoomLevelDisplay();
        });
      }

      if (fullscreenButton && pdfViewerContainer) {
        fullscreenButton.addEventListener('click', () => {
          try {
            if (!document.fullscreenElement &&
                !document.webkitFullscreenElement &&
                !document.mozFullScreenElement &&
                !document.msFullscreenElement) {
              
              // Check if fullscreen is supported
              if (!document.fullscreenEnabled &&
                  !document.webkitFullscreenEnabled &&
                  !document.mozFullScreenEnabled &&
                  !document.msFullscreenEnabled) {
                console.log('Fullscreen is not supported or allowed in this browser');
                return;
              }
              
              // Try different fullscreen methods for browser compatibility
              if (pdfViewerContainer.requestFullscreen) {
                pdfViewerContainer.requestFullscreen().catch(err => {
                  console.log('Fullscreen request failed:', err.name, err.message);
                });
              } else if (pdfViewerContainer.webkitRequestFullscreen) {
                pdfViewerContainer.webkitRequestFullscreen();
              } else if (pdfViewerContainer.mozRequestFullScreen) {
                pdfViewerContainer.mozRequestFullScreen();
              } else if (pdfViewerContainer.msRequestFullscreen) {
                pdfViewerContainer.msRequestFullscreen();
              } else {
                console.log('No fullscreen method available');
              }
            } else {
              // Exit fullscreen
              if (document.exitFullscreen) {
                document.exitFullscreen().catch(err => {
                  console.log('Exit fullscreen failed:', err.name, err.message);
                });
              } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
              } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
              } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
              }
            }
          } catch (err) {
            console.error('Fullscreen error:', err);
            // Don't show alerts for fullscreen errors - just log them
          }
        });
      }

    // Listen for fullscreen changes to update button text/icon if needed
    const fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
    
    fullscreenEvents.forEach(eventName => {
      document.addEventListener(eventName, () => {
        // For now, we don't change the button appearance based on state,
        // but this is where you could do it.
        // For example, change "Full Screen" to "Exit Full Screen"
        const isFullscreen = !!(document.fullscreenElement ||
                                document.webkitFullscreenElement ||
                                document.mozFullScreenElement ||
                                document.msFullscreenElement);
        console.log('Fullscreen state changed:', isFullscreen);
      });
    });

      // --- Go to Page Functionality ---
      function switchToPageDisplayView() {
        if (pageNavigationGroup) {
          pageNavigationGroup.style.display = 'none';
        }
        if (pageInput) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
        }
        if (pageInputErrorIcon) {
          pageInputErrorIcon.style.display = 'none';
          pageInputErrorIcon.removeAttribute('title');
        }
        if (pageIndicator) {
          pageIndicator.style.display = 'inline-flex';
        }
      }

      function switchToPageInputView() {
        if (pageIndicator) {
          pageIndicator.style.display = 'none';
        }
        if (pageNavigationGroup) {
          pageNavigationGroup.style.display = 'block';
        }
        if (pageInput) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
          pageInput.value = currentPageNum.toString();
          pageInput.max = totalPages.toString();
          pageInput.focus();
          pageInput.select();
        }
        if (pageInputErrorIcon) {
          pageInputErrorIcon.style.display = 'none';
          pageInputErrorIcon.removeAttribute('title');
        }
      }

      if (pageIndicator) {
        pageIndicator.addEventListener('click', switchToPageInputView);
      }

      async function handleGoToPage() {
        if (!pageInput) return;
        const newPageNum = parseInt(pageInput.value, 10);
        if (!isNaN(newPageNum) && newPageNum >= 1 && newPageNum <= totalPages) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
          if (pageInputErrorIcon) {
            pageInputErrorIcon.style.display = 'none';
            pageInputErrorIcon.removeAttribute('title');
          }
          if (newPageNum !== currentPageNum) {
            await renderPage(newPageNum);
          }
          switchToPageDisplayView();
        } else {
          pageInput.classList.add('input-error');
          pageInput.setAttribute('aria-invalid', 'true');
          if (pageInputErrorIcon) {
            pageInputErrorIcon.style.display = 'inline';
            pageInputErrorIcon.title = `Choose a page number between 1 and ${totalPages}.`;
          }
          pageInput.focus();
          pageInput.select();
        }
      }

      if (gotoPageBtn) {
        gotoPageBtn.addEventListener('click', handleGoToPage);
      }
      
      if (pageInput) {
        pageInput.addEventListener('keypress', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault(); // Prevent form submission if it's in a form
            handleGoToPage();
          }
        });
      }

      // Click outside to cancel page input - store reference for cleanup
      if (pageNavigationGroup && pageIndicator) {
        const clickOutsideHandler = function(event) {
          if (pageNavigationGroup.style.display === 'block') {
            const isClickInsideNavGroup = pageNavigationGroup.contains(event.target);
            const isClickOnPageIndicator = pageIndicator.contains(event.target);
            if (!isClickInsideNavGroup && !isClickOnPageIndicator) {
              switchToPageDisplayView();
            }
          }
        };
        
        // Remove existing listener if it exists
        if (window.pdfClickOutsideHandler) {
          document.removeEventListener('click', window.pdfClickOutsideHandler, true);
        }
        
        window.pdfClickOutsideHandler = clickOutsideHandler;
        document.addEventListener('click', clickOutsideHandler, true);
      }

      if (pageInputErrorIcon) {
        pageInputErrorIcon.addEventListener('click', () => {
          if (pageInputErrorIcon.style.display !== 'none' && pageInputErrorIcon.title) {
            alert(pageInputErrorIcon.title);
          }
        });
      }

    } catch (error) {
      console.error("Error loading or rendering PDF:", error);
      const container = document.getElementById('pdf-viewer-container');
      if (container) {
        container.innerHTML = `<p>Error loading PDF: ${error.message}.</p>`;
      }
    }
  }

  // Initialize immediately
  initializePdfViewer();

  // Reinitialize after view transitions
  document.addEventListener('astro:page-load', () => {
    console.log('Page loaded, reinitializing PDF viewer');
    initializePdfViewer();
  });

  // Also reinitialize on beforeunload to ensure cleanup
  window.addEventListener('beforeunload', () => {
    cleanupPdfViewer();
  });
</script>

<style>
  .pdf-viewer-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 1px solid #ccc;
    background-color: #f9f9f9;
    padding: 10px;
    box-sizing: border-box;
    /* Ensure it respects the parent's height constraints */
    height: 100%; 
    overflow: hidden; /* Hide canvas overflow if any */
  }

  #pdf-canvas {
    border: 1px solid #bbb;
    /* max-width: 100%; */ /* Let canvas size be determined by PDF.js viewport */
    /* Height will be set by PDF.js based on page dimensions and scale */
    /* We'll make the canvas scrollable if it's taller than its container */
    display: block; /* Remove extra space below canvas */
    margin-bottom: 10px;
    flex-shrink: 0; /* Prevent canvas from shrinking within its flex parent (.canvas-wrapper) */
    /* Ensure proper orientation and prevent flipping */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
  }
  
  /* Make the canvas container scrollable if PDF page is tall */
  .pdf-viewer-container > #pdf-canvas {
      overflow-y: auto; /* This won't work directly on canvas, need a wrapper or adjust container */
      /* For now, let's assume the main container will handle scrolling if needed,
         or the canvas itself will be sized to fit.
         A better approach for tall pages is to put canvas in a scrollable div.
         Let's adjust the container to be scrollable for the canvas.
      */
  }

  /* Let's create a dedicated scrollable area for the canvas */
  .canvas-wrapper {
    width: 100%;
    flex-grow: 1; /* Takes up available vertical space */
    overflow-y: auto; /* Allows scrolling for tall PDF pages */
    overflow-x: auto; /* Allows scrolling for wide PDF pages (zoomed in) */
    display: flex;
    justify-content: center; /* Center canvas if it's narrower than wrapper */
    margin-bottom: 10px;
  }


  .pdf-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px 0;
    background-color: #eee;
    width: 100%;
    box-sizing: border-box;
    flex-shrink: 0; /* Prevent controls from shrinking */
  }

  .pdf-controls button {
    padding: 8px 12px;
    margin: 0 10px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  .pdf-controls button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
  }

  .pdf-controls span {
    margin: 0 5px;
    font-size: 1em;
  }
  .page-indicator {
    cursor: pointer;
    padding: 0 5px; /* Give some clickable area */
    display: inline-flex; /* To align text nicely */
    align-items: center;
  }
  /* .page-input-container is now a child of page-navigation-group */
  .page-input-container {
    display: flex;
    align-items: center;
    justify-content: center; /* Center input and button if group is wider */
    /* margin: 0 5px; /* Margin now on page-navigation-group or individual elements */
  }
  /* .page-input-error-message class removed */
  #page-input {
    width: 50px; /* Slightly wider for 3 digits */
    text-align: right;
    margin-right: 5px;
    padding: 4px 6px; /* Increased padding for better touch */
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 0.95em;
  }
  #page-input.input-error {
    border-color: #d9534f; /* Red border for error */
    box-shadow: 0 0 0 0.2rem rgba(217, 83, 79, 0.25); /* Optional: subtle glow */
  }
  .page-input-error-icon {
    color: #d9534f; /* Red color for the icon */
    margin-left: 5px;
    cursor: help; /* Indicates more info on hover */
    font-weight: bold;
    display: inline-flex; /* To align with button/input */
    align-items: center;
  }
  #goto-page-btn {
    padding: 5px 10px; /* Increased padding */
    font-size: 0.9em;
    /* background-color: #007bff; Already default button style */
    /* color: white; Already default button style */
    /* border: none; Already default button style */
    /* border-radius: 3px; Already default button style */
    /* cursor: pointer; Already default button style */
    line-height: 1; /* Ensure text is centered well */
  }

  .spacer {
    margin: 0 10px; /* Adds some space */
  }

  .pdf-controls button .icon {
    display: none; /* Hidden by default, shown on mobile for prev/next */
    font-weight: bold; /* Make icons bold by default if they are shown */
  }
  .pdf-controls button .text {
    display: inline; /* Shown by default, hidden on mobile for specified buttons */
  }

  /* Fullscreen button icon always visible */
  .pdf-controls button#fullscreen-btn .icon {
    display: inline;
    font-size: 1.2em; /* Make icon a bit larger */
  }
   /* Fullscreen button text always hidden (already set inline, but good for clarity) */
  .pdf-controls button#fullscreen-btn .text {
    display: none !important;
  }


  /* Mobile styles */
  @media (max-width: 768px) {
    .pdf-controls button#prev-page .text,
    .pdf-controls button#next-page .text { /* Fullscreen text already handled */
      display: none;
    }

    .pdf-controls button#prev-page .icon,
    .pdf-controls button#next-page .icon { /* Fullscreen icon already handled */
      display: inline;
    }
    
    /* Zoom buttons on mobile */
    .pdf-controls button.zoom-button {
      font-weight: bold;
      padding: 8px; /* Make it more square-like and consistent with other mobile icon buttons */
    }

    .zoom-level-display {
      display: none; /* Hide zoom percentage on mobile */
    }

    .pdf-controls button {
      padding: 8px; /* Default padding for icon buttons on mobile */
      margin: 0 5px;
    }
     /* Ensure fullscreen icon button has consistent padding on mobile */
    .pdf-controls button#fullscreen-btn {
        padding: 8px 10px;
    }
  }
</style>