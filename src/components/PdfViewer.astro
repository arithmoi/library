---
// src/components/PdfViewer.astro
export interface Props {
  pdfUrl: string;
}

const { pdfUrl } = Astro.props;

// Construct the worker URL. This is crucial for PDF.js.
// It assumes pdf.worker.min.mjs is available relative to the built assets.
// Astro typically places files from node_modules in /node_modules/ after build,
// but for development, we might need a more direct path or ensure it's copied.
// For now, let's aim for a path that works in production.
// We'll need to ensure the worker file is correctly served.
// This path assumes pdf.worker.min.mjs has been copied to the public directory.
const pdfjsWorkerSrc = `/pdf.worker.min.mjs`;

---
<div id="pdf-viewer-container" class="pdf-viewer-container">
  <div class="canvas-wrapper">
    <canvas id="pdf-canvas"></canvas>
  </div>
  <div class="pdf-controls">
    <button id="prev-page">
      <span class="icon"><</span>
      <span class="text">Previous</span>
    </button>
    <div id="page-indicator" class="page-indicator">
      <span id="page-num-display"></span>&nbsp;/&nbsp;<span id="page-count-display"></span>
    </div>
    <div id="page-navigation-group" style="display: none;">
      <div id="page-input-container" class="page-input-container">
        <input type="number" id="page-input" min="1" />
        <button id="goto-page-btn">Go</button>
        <span id="page-input-error-icon" class="page-input-error-icon" style="display: none;">&#9432;</span>
      </div>
    </div>
    <button id="next-page">
      <span class="icon">></span>
      <span class="text">Next</span>
    </button>
    <span class="spacer"></span>
    <button id="zoom-out" class="zoom-button">-</button>
    <span id="zoom-level" class="zoom-level-display">100%</span>
    <button id="zoom-in" class="zoom-button">+</button>
    <span class="spacer"></span>
    <button id="fullscreen-btn">
      <span class="icon">&#x2922;</span> <!-- Unicode for fullscreen icon ‚§¢ -->
      <span class="text" style="display: none;">Full Screen</span> <!-- Text always hidden -->
    </button>
    
    <!-- NEW: Hamburger Menu Button -->
    <button id="menu-btn" class="menu-button" title="More Options">
      <span class="icon">‚ò∞</span>
    </button>
  </div>

  <!-- NEW: Modal Overlay Menu -->
  <div id="pdf-menu-overlay" class="pdf-menu-overlay" style="display: none;">
    <div class="pdf-menu-modal">
      <div class="menu-header">
        <h3 class="menu-title">üìñ PDF Viewer Options</h3>
        <button id="menu-close-btn" class="menu-close-btn">&times;</button>
      </div>
      
      <div class="menu-content">
        <div class="menu-section">
          <h4 class="menu-section-title">üìñ Reading Mode</h4>
          <div class="menu-options">
            <label class="menu-option">
              <input type="radio" name="reading-mode" value="read" checked>
              <span class="option-icon">üìñ</span>
              <span class="option-text">Read Only</span>
            </label>
            <label class="menu-option">
              <input type="radio" name="reading-mode" value="audio">
              <span class="option-icon">üîä</span>
              <span class="option-text">Audio Mode</span>
            </label>
            <label class="menu-option">
              <input type="radio" name="reading-mode" value="video">
              <span class="option-icon">üì∫</span>
              <span class="option-text">Video Mode</span>
            </label>
            <label class="menu-option">
              <input type="radio" name="reading-mode" value="pip">
              <span class="option-icon">üñºÔ∏è</span>
              <span class="option-text">Picture-in-Picture</span>
            </label>
          </div>
        </div>

        <!-- TTS Controls Section (shown when audio modes active) -->
        <div id="tts-menu-section" class="menu-section" style="display: none;">
          <h4 class="menu-section-title">üéµ Audio Controls</h4>
          <div class="menu-controls">
            <div class="control-row">
              <button id="tts-play-pause" class="menu-control-btn">
                <span class="icon">‚ñ∂Ô∏è</span>
                <span class="text">Play</span>
              </button>
              <button id="tts-stop" class="menu-control-btn">
                <span class="icon">‚èπÔ∏è</span>
                <span class="text">Stop</span>
              </button>
            </div>
            <div class="control-row">
              <label class="control-label">üé§ Voice:</label>
              <select id="voice-selector" class="menu-select">
                <option>Default Voice</option>
              </select>
            </div>
            <div class="control-row">
              <label class="control-label">‚ö° Speed:</label>
              <select id="speed-selector" class="menu-select">
                <option value="0.5">0.5x</option>
                <option value="0.75">0.75x</option>
                <option value="1.0" selected>1.0x</option>
                <option value="1.25">1.25x</option>
                <option value="1.5">1.5x</option>
                <option value="2.0">2.0x</option>
              </select>
            </div>
            <div class="control-row">
              <label class="menu-option">
                <input type="checkbox" id="auto-advance">
                <span class="option-text">üîÑ Auto-advance pages</span>
              </label>
            </div>
          </div>
        </div>

        <div class="menu-section">
          <h4 class="menu-section-title">üé® Display Options</h4>
          <div class="menu-controls">
            <div class="control-row">
              <label class="control-label">üåà Highlight:</label>
              <input type="color" id="highlight-color" value="#ffff00" class="color-picker">
            </div>
            <div class="control-row">
              <label class="menu-option">
                <input type="checkbox" id="dark-mode">
                <span class="option-text">üåô Dark Mode</span>
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ pdfUrl, pdfjsWorkerSrc }}>
  // Import the working Cloud TTS Manager
  import('/src/components/CloudTtsManager.js');
  // Global variables to track current PDF state
  let currentPdfDoc = null;
  let currentPageNum = 1;
  let currentScale = 1.5;
  let totalPages = 0;
  let isRendering = false;
  let renderTask = null;
  let renderQueue = [];
  let isProcessingQueue = false;

  // Global menu variables - moved to global scope to fix variable access issues
  let menuBtn, menuOverlay, menuModal, menuCloseBtn, ttsMenuSection, readingModeInputs;
  let ttsPlayPauseBtn, ttsStopBtn, voiceSelector, speedSelector;
  let autoAdvanceCheckbox, highlightColorInput, darkModeCheckbox;
  let menuInitialized = false;
  let lastToggleTime = 0;

  // Global TTS state variables
  let currentReadingMode = 'read';
  let ttsUtterance = null;
  let isPlaying = false;
  let currentPageText = '';
  let availableVoices = [];
  let selectedVoice = null;
  let speechRate = 1.0;
  let autoAdvance = false;
  let highlightColor = '#ffff00';
  let darkMode = false;

  // Cleanup function to remove existing event listeners
  function cleanupPdfViewer() {
    // Cancel any ongoing render task
    if (renderTask) {
      try {
        renderTask.cancel();
      } catch (e) {
        console.log('Render task already completed or cancelled');
      }
      renderTask = null;
    }
    
    // Clear render queue
    renderQueue = [];
    isProcessingQueue = false;
    
    // Remove click outside handler
    if (window.pdfClickOutsideHandler) {
      document.removeEventListener('click', window.pdfClickOutsideHandler, true);
      window.pdfClickOutsideHandler = null;
    }
    
    // Reset menu initialization state
    menuInitialized = false;
    if (menuBtn && menuBtn.hasAttribute('data-menu-listener')) {
      menuBtn.removeAttribute('data-menu-listener');
    }
    
    // Clear canvas
    const canvas = document.getElementById('pdf-canvas');
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }
    
    // Reset global state
    currentPdfDoc = null;
    currentPageNum = 1;
    currentScale = 1.5;
    totalPages = 0;
    isRendering = false;
    window.currentPdfUrl = null;
  }

  async function initializePdfViewer() {
    try {
      // Check if container exists
      const container = document.getElementById('pdf-viewer-container');
      if (!container) {
        console.error('PDF container not found');
        return;
      }

      // Force cleanup and reload for every initialization to ensure clean state
      console.log(`Initializing PDF viewer with URL: ${pdfUrl}`);
      console.log(`Previous URL was: ${window.currentPdfUrl}`);
      
      // Always cleanup to ensure clean state
      cleanupPdfViewer();
      
      // Set current URL immediately to prevent race conditions
      window.currentPdfUrl = pdfUrl;
      console.log('Loading PDF:', pdfUrl);

      // Dynamically import pdfjs-dist to keep initial load small
      const pdfjsLib = await import('/pdf.min.mjs');
      if (!pdfjsLib.GlobalWorkerOptions.workerSrc && pdfjsWorkerSrc) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorkerSrc;
      }

      const loadingTask = pdfjsLib.getDocument(pdfUrl);
      currentPdfDoc = await loadingTask.promise;
      totalPages = currentPdfDoc.numPages;
      
      console.log(`PDF loaded successfully: ${totalPages} pages`);

      // Get DOM elements
      const pageNumElement = document.getElementById('page-num-display');
      const pageCountElement = document.getElementById('page-count-display');
      const pageIndicator = document.getElementById('page-indicator');
      const pageNavigationGroup = document.getElementById('page-navigation-group');
      const pageInputContainer = document.getElementById('page-input-container');
      const pageInput = document.getElementById('page-input');
      const gotoPageBtn = document.getElementById('goto-page-btn');
      const pageInputErrorIcon = document.getElementById('page-input-error-icon');
      const prevButton = document.getElementById('prev-page');
      const nextButton = document.getElementById('next-page');
      const zoomOutButton = document.getElementById('zoom-out');
      const zoomInButton = document.getElementById('zoom-in');
      const zoomLevelElement = document.getElementById('zoom-level');
      const fullscreenButton = document.getElementById('fullscreen-btn');
      const pdfViewerContainer = document.getElementById('pdf-viewer-container');

      // Initialize page display with correct total pages
      if (pageCountElement) {
        pageCountElement.textContent = totalPages.toString();
        console.log(`Set page count display to: ${totalPages}`);
      } else {
        console.error('Page count element not found');
      }
      
      if (pageNumElement) {
        pageNumElement.textContent = currentPageNum.toString();
        console.log(`Set current page display to: ${currentPageNum}`);
      } else {
        console.error('Page number element not found');
      }
      
      // Set page input max value
      if (pageInput) {
        pageInput.max = totalPages.toString();
        pageInput.min = "1";
      }

      function updateZoomLevelDisplay() {
        if (zoomLevelElement) {
          zoomLevelElement.textContent = `${Math.round(currentScale * 100)}%`;
        }
      }

      // Queue-based rendering system to prevent canvas conflicts
      async function queueRender(pageNum, scale = null) {
        return new Promise((resolve, reject) => {
          const renderRequest = {
            pageNum,
            scale: scale || currentScale,
            resolve,
            reject
          };
          
          renderQueue.push(renderRequest);
          processRenderQueue();
        });
      }

      async function processRenderQueue() {
        if (isProcessingQueue || renderQueue.length === 0) {
          return;
        }
        
        isProcessingQueue = true;
        
        while (renderQueue.length > 0) {
          const request = renderQueue.shift();
          
          try {
            await renderPageInternal(request.pageNum, request.scale);
            request.resolve();
          } catch (error) {
            request.reject(error);
          }
        }
        
        isProcessingQueue = false;
      }

      async function renderPageInternal(num, scale) {
        if (!currentPdfDoc) {
          throw new Error('Cannot render page: missing PDF document');
        }
        
        if (num < 1 || num > totalPages) {
          throw new Error(`Invalid page number: ${num}. Valid range: 1-${totalPages}`);
        }
        
        // Cancel any ongoing render operation
        if (renderTask) {
          try {
            renderTask.cancel();
          } catch (e) {
            console.log('Previous render task already completed');
          }
          renderTask = null;
        }
        
        console.log(`Rendering page ${num} of ${totalPages} at scale ${scale}`);
        
        const page = await currentPdfDoc.getPage(num);
        const viewport = page.getViewport({ scale });

        // Get the canvas container
        const canvasWrapper = document.querySelector('.canvas-wrapper');
        if (!canvasWrapper) {
          throw new Error('Canvas wrapper not found');
        }

        // Always create a fresh canvas to avoid conflicts
        const oldCanvas = document.getElementById('pdf-canvas');
        if (oldCanvas) {
          oldCanvas.remove();
        }
        
        const canvas = document.createElement('canvas');
        canvas.id = 'pdf-canvas';
        
        // Set canvas dimensions to match viewport
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        // Set the CSS display size of the canvas to match its drawing resolution
        canvas.style.width = viewport.width + 'px';
        canvas.style.height = viewport.height + 'px';
        
        // Add canvas to DOM
        canvasWrapper.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        
        const renderContext = {
          canvasContext: ctx,
          viewport: viewport,
        };
        
        // Store the render task so we can cancel it if needed
        renderTask = page.render(renderContext);
        await renderTask.promise;
        renderTask = null;
        
        // Update current page number and scale
        currentPageNum = num;
        currentScale = scale;
        
        // Update page display
        const currentPageNumElement = document.getElementById('page-num-display');
        if (currentPageNumElement) {
          currentPageNumElement.textContent = num.toString();
        }

        // Update button states
        const currentPrevButton = document.getElementById('prev-page');
        const currentNextButton = document.getElementById('next-page');
        if (currentPrevButton) {
          currentPrevButton.disabled = num <= 1;
        }
        if (currentNextButton) {
          currentNextButton.disabled = num >= totalPages;
        }
        
        console.log(`Successfully rendered page ${num}`);
      }

      // Public render function that uses the queue
      async function renderPage(num, scale = null) {
        try {
          await queueRender(num, scale);
        } catch (error) {
          if (error.name === 'RenderingCancelledException') {
            console.log('Render operation was cancelled');
          } else {
            console.error('Error rendering PDF page:', error);
            const container = document.getElementById('pdf-viewer-container');
            if (container) {
              const canvasWrapper = container.querySelector('.canvas-wrapper');
              if (canvasWrapper) {
                canvasWrapper.innerHTML = `<p>Error rendering page ${num}: ${error.message}</p>`;
              }
            }
          }
        }
      }

      // Add event listeners with null checks
      if (prevButton) {
        prevButton.addEventListener('click', async () => {
          if (currentPageNum <= 1) return;
          await renderPage(currentPageNum - 1);
        });
      }

      if (nextButton) {
        nextButton.addEventListener('click', async () => {
          if (currentPageNum >= totalPages) return;
          await renderPage(currentPageNum + 1);
        });
      }

      // Initial render
      await renderPage(currentPageNum);
      updateZoomLevelDisplay();

      if (zoomInButton) {
        zoomInButton.addEventListener('click', async () => {
          const newScale = currentScale + 0.25;
          await renderPage(currentPageNum, newScale);
          updateZoomLevelDisplay();
        });
      }

      if (zoomOutButton) {
        zoomOutButton.addEventListener('click', async () => {
          if (currentScale <= 0.25) return; // Minimum scale
          const newScale = currentScale - 0.25;
          await renderPage(currentPageNum, newScale);
          updateZoomLevelDisplay();
        });
      }

      if (fullscreenButton && pdfViewerContainer) {
        fullscreenButton.addEventListener('click', () => {
          try {
            if (!document.fullscreenElement &&
                !document.webkitFullscreenElement &&
                !document.mozFullScreenElement &&
                !document.msFullscreenElement) {
              
              // Check if fullscreen is supported
              if (!document.fullscreenEnabled &&
                  !document.webkitFullscreenEnabled &&
                  !document.mozFullScreenEnabled &&
                  !document.msFullscreenEnabled) {
                console.log('Fullscreen is not supported or allowed in this browser');
                return;
              }
              
              // Try different fullscreen methods for browser compatibility
              if (pdfViewerContainer.requestFullscreen) {
                pdfViewerContainer.requestFullscreen().catch(err => {
                  console.log('Fullscreen request failed:', err.name, err.message);
                });
              } else if (pdfViewerContainer.webkitRequestFullscreen) {
                pdfViewerContainer.webkitRequestFullscreen();
              } else if (pdfViewerContainer.mozRequestFullScreen) {
                pdfViewerContainer.mozRequestFullScreen();
              } else if (pdfViewerContainer.msRequestFullscreen) {
                pdfViewerContainer.msRequestFullscreen();
              } else {
                console.log('No fullscreen method available');
              }
            } else {
              // Exit fullscreen
              if (document.exitFullscreen) {
                document.exitFullscreen().catch(err => {
                  console.log('Exit fullscreen failed:', err.name, err.message);
                });
              } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
              } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
              } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
              }
            }
          } catch (err) {
            console.error('Fullscreen error:', err);
            // Don't show alerts for fullscreen errors - just log them
          }
        });
      }

    // Listen for fullscreen changes to update button text/icon if needed
    const fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
    
    fullscreenEvents.forEach(eventName => {
      document.addEventListener(eventName, () => {
        // For now, we don't change the button appearance based on state,
        // but this is where you could do it.
        // For example, change "Full Screen" to "Exit Full Screen"
        const isFullscreen = !!(document.fullscreenElement ||
                                document.webkitFullscreenElement ||
                                document.mozFullScreenElement ||
                                document.msFullscreenElement);
        console.log('Fullscreen state changed:', isFullscreen);
      });
    });

      // --- Go to Page Functionality ---
      function switchToPageDisplayView() {
        if (pageNavigationGroup) {
          pageNavigationGroup.style.display = 'none';
        }
        if (pageInput) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
        }
        if (pageInputErrorIcon) {
          pageInputErrorIcon.style.display = 'none';
          pageInputErrorIcon.removeAttribute('title');
        }
        if (pageIndicator) {
          pageIndicator.style.display = 'inline-flex';
        }
      }

      function switchToPageInputView() {
        if (pageIndicator) {
          pageIndicator.style.display = 'none';
        }
        if (pageNavigationGroup) {
          pageNavigationGroup.style.display = 'block';
        }
        if (pageInput) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
          pageInput.value = currentPageNum.toString();
          pageInput.max = totalPages.toString();
          pageInput.focus();
          pageInput.select();
        }
        if (pageInputErrorIcon) {
          pageInputErrorIcon.style.display = 'none';
          pageInputErrorIcon.removeAttribute('title');
        }
      }

      if (pageIndicator) {
        pageIndicator.addEventListener('click', switchToPageInputView);
      }

      async function handleGoToPage() {
        if (!pageInput) return;
        const newPageNum = parseInt(pageInput.value, 10);
        if (!isNaN(newPageNum) && newPageNum >= 1 && newPageNum <= totalPages) {
          pageInput.classList.remove('input-error');
          pageInput.removeAttribute('title');
          pageInput.removeAttribute('aria-invalid');
          if (pageInputErrorIcon) {
            pageInputErrorIcon.style.display = 'none';
            pageInputErrorIcon.removeAttribute('title');
          }
          if (newPageNum !== currentPageNum) {
            await renderPage(newPageNum);
          }
          switchToPageDisplayView();
        } else {
          pageInput.classList.add('input-error');
          pageInput.setAttribute('aria-invalid', 'true');
          if (pageInputErrorIcon) {
            pageInputErrorIcon.style.display = 'inline';
            pageInputErrorIcon.title = `Choose a page number between 1 and ${totalPages}.`;
          }
          pageInput.focus();
          pageInput.select();
        }
      }

      if (gotoPageBtn) {
        gotoPageBtn.addEventListener('click', handleGoToPage);
      }
      
      if (pageInput) {
        pageInput.addEventListener('keypress', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault(); // Prevent form submission if it's in a form
            handleGoToPage();
          }
        });
      }

      // Click outside to cancel page input - store reference for cleanup
      if (pageNavigationGroup && pageIndicator) {
        const clickOutsideHandler = function(event) {
          // Don't interfere with menu overlay
          if (menuOverlay && menuOverlay.classList.contains('show')) {
            return;
          }
          
          if (pageNavigationGroup.style.display === 'block') {
            const isClickInsideNavGroup = pageNavigationGroup.contains(event.target);
            const isClickOnPageIndicator = pageIndicator.contains(event.target);
            if (!isClickInsideNavGroup && !isClickOnPageIndicator) {
              switchToPageDisplayView();
            }
          }
        };
        
        // Remove existing listener if it exists
        if (window.pdfClickOutsideHandler) {
          document.removeEventListener('click', window.pdfClickOutsideHandler, true);
        }
        
        window.pdfClickOutsideHandler = clickOutsideHandler;
        document.addEventListener('click', clickOutsideHandler, true);
      }

      if (pageInputErrorIcon) {
        pageInputErrorIcon.addEventListener('click', () => {
          if (pageInputErrorIcon.style.display !== 'none' && pageInputErrorIcon.title) {
            alert(pageInputErrorIcon.title);
          }
        });
      }

      // --- NEW: Hamburger Menu & TTS Functionality ---
      // Note: All variables moved to global scope to fix access issues

      // Function to initialize menu elements and event listeners
      function initializeMenuElements() {
        // Prevent double initialization
        if (menuInitialized) {
          console.log('Menu already initialized, skipping...');
          return;
        }
        
        // Get menu elements
        menuBtn = document.getElementById('menu-btn');
        menuOverlay = document.getElementById('pdf-menu-overlay');
        menuModal = document.querySelector('.pdf-menu-modal');
        menuCloseBtn = document.getElementById('menu-close-btn');
        ttsMenuSection = document.getElementById('tts-menu-section');
        readingModeInputs = document.querySelectorAll('input[name="reading-mode"]');
        ttsPlayPauseBtn = document.getElementById('tts-play-pause');
        ttsStopBtn = document.getElementById('tts-stop');
        voiceSelector = document.getElementById('voice-selector');
        speedSelector = document.getElementById('speed-selector');
        autoAdvanceCheckbox = document.getElementById('auto-advance');
        highlightColorInput = document.getElementById('highlight-color');
        darkModeCheckbox = document.getElementById('dark-mode');

        console.log('Menu elements found:', {
          menuBtn: !!menuBtn,
          menuOverlay: !!menuOverlay,
          menuModal: !!menuModal,
          menuCloseBtn: !!menuCloseBtn,
          ttsMenuSection: !!ttsMenuSection
        });

        // Set up event listeners
        setupMenuEventListeners();
        
        // Mark as initialized
        menuInitialized = true;
        console.log('Menu initialization completed');
      }

      // Voice loading state management
      let voiceLoadingAttempts = 0;
      let maxVoiceLoadingAttempts = 10;
      let voiceLoadingInterval = null;
      let voicesLoaded = false;
      let webTTSFallback = false;
      let webTTSEnabled = false;

      // Test TTS functionality with voice availability check
      function testTTS() {
        console.log('Testing basic TTS functionality...');
        if (!window.speechSynthesis) {
          console.error('Speech synthesis not available');
          showTTSError('Speech synthesis is not supported in this browser.');
          return false;
        }
        
        const voices = speechSynthesis.getVoices();
        if (voices.length === 0) {
          console.warn('No voices available for TTS test');
          return false;
        }
        
        try {
          const testUtterance = new SpeechSynthesisUtterance('Testing speech synthesis');
          testUtterance.volume = 0.1; // Very quiet test
          testUtterance.rate = 2; // Fast test
          
          testUtterance.onstart = () => {
            console.log('‚úÖ TTS test successful - speech synthesis is working');
            hideTTSError();
          };
          
          testUtterance.onerror = (event) => {
            console.error('‚ùå TTS test failed:', event.error);
            showTTSError(`TTS test failed: ${event.error}`);
          };
          
          speechSynthesis.speak(testUtterance);
          return true;
        } catch (error) {
          console.error('‚ùå TTS test error:', error);
          showTTSError(`TTS error: ${error.message}`);
          return false;
        }
      }

      // Show TTS error message to user with enhanced guidance
      function showTTSError(message) {
        let errorDiv = document.getElementById('tts-error-message');
        if (!errorDiv) {
          errorDiv = document.createElement('div');
          errorDiv.id = 'tts-error-message';
          errorDiv.style.cssText = `
            background: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            max-width: 600px;
            line-height: 1.5;
          `;
          
          // Insert after the TTS controls section
          const ttsSection = document.querySelector('.tts-controls-section');
          if (ttsSection) {
            ttsSection.parentNode.insertBefore(errorDiv, ttsSection.nextSibling);
          }
        }
        
        errorDiv.innerHTML = `
          <div style="margin-bottom: 15px;">
            <strong>‚ö†Ô∏è Text-to-Speech Not Available</strong><br>
            ${message}
          </div>
          
          <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 12px; border-radius: 4px; margin: 10px 0;">
            <strong>üí° Alternative Options:</strong><br>
            ‚Ä¢ Use your browser's built-in "Read Aloud" extension<br>
            ‚Ä¢ Copy text and paste into online TTS services<br>
            ‚Ä¢ Use screen reader software if available<br>
            ‚Ä¢ Switch to "Read" mode for manual reading
          </div>
          
          <details style="margin-top: 10px;">
            <summary style="cursor: pointer; font-weight: bold;">üîß Technical Setup Instructions</summary>
            <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
              <strong>Quick Browser Test:</strong><br>
              Open browser console (F12) and run: <code>speechSynthesis.getVoices().length</code><br>
              If it returns 0, your system needs TTS voices installed.<br><br>
              
              <strong>Installation Commands:</strong><br>
              <strong>Ubuntu/Debian:</strong> <code>sudo apt install espeak espeak-data</code><br>
              <strong>Fedora:</strong> <code>sudo dnf install espeak espeak-devel</code><br>
              <strong>Arch:</strong> <code>sudo pacman -S espeak espeak-ng</code><br><br>
              
              <strong>After installation:</strong> Restart your browser completely.
            </div>
          </details>
        `;
        errorDiv.style.display = 'block';
      }

      // Hide TTS error message
      function hideTTSError() {
        const errorDiv = document.getElementById('tts-error-message');
        if (errorDiv) {
          errorDiv.style.display = 'none';
        }
      }

      // Show TTS success message
      function showTTSSuccess(message) {
        let successDiv = document.getElementById('tts-success-message');
        if (!successDiv) {
          successDiv = document.createElement('div');
          successDiv.id = 'tts-success-message';
          successDiv.style.cssText = `
            background: #d4edda;
            border: 1px solid #28a745;
            color: #155724;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
            display: none;
          `;
          
          // Insert after the TTS controls section
          const ttsSection = document.querySelector('.tts-controls-section');
          if (ttsSection) {
            ttsSection.parentNode.insertBefore(successDiv, ttsSection.nextSibling);
          }
        }
        
        successDiv.innerHTML = `
          <strong>‚úÖ ${message}</strong>
        `;
        successDiv.style.display = 'block';
        
        // Hide after 5 seconds
        setTimeout(() => {
          successDiv.style.display = 'none';
        }, 5000);
      }

      // Web-based TTS fallback using ResponsiveVoice API
      function initializeWebTTS() {
        console.log('Initializing web-based TTS fallback...');
        
        // Check if ResponsiveVoice is already loaded
        if (window.responsiveVoice) {
          console.log('‚úÖ ResponsiveVoice already available');
          webTTSEnabled = true;
          return Promise.resolve(true);
        }
        
        return new Promise((resolve) => {
          // Load ResponsiveVoice script
          const script = document.createElement('script');
          script.src = 'https://code.responsivevoice.org/responsivevoice.js?key=FREE';
          script.onload = () => {
            console.log('‚úÖ ResponsiveVoice loaded successfully');
            webTTSEnabled = true;
            
            // Wait for ResponsiveVoice to initialize
            const checkReady = () => {
              if (window.responsiveVoice && window.responsiveVoice.voiceSupport()) {
                console.log('‚úÖ ResponsiveVoice ready for use');
                resolve(true);
              } else {
                setTimeout(checkReady, 100);
              }
            };
            checkReady();
          };
          script.onerror = () => {
            console.error('‚ùå Failed to load ResponsiveVoice');
            resolve(false);
          };
          document.head.appendChild(script);
        });
      }

      // Web TTS speak function
      function webTTSSpeak(text) {
        if (!webTTSEnabled || !window.responsiveVoice) {
          console.error('Web TTS not available');
          return false;
        }
        
        try {
          // Stop any existing speech
          window.responsiveVoice.cancel();
          
          // Configure voice settings
          const voiceSettings = {
            rate: speechRate,
            pitch: 1,
            volume: 1,
            onstart: () => {
              console.log('‚úÖ Web TTS started successfully');
              isPlaying = true;
              updateTtsControlsInMenu();
              hideTTSError();
            },
            onend: () => {
              console.log('Web TTS ended');
              isPlaying = false;
              updateTtsControlsInMenu();
              
              // Auto-advance to next page if enabled
              if (autoAdvance && currentPageNum < totalPages) {
                setTimeout(async () => {
                  await renderPage(currentPageNum + 1);
                  currentPageText = ''; // Reset text for new page
                  if (currentReadingMode === 'audio' || currentReadingMode === 'video') {
                    startTTS();
                  }
                }, 1000);
              }
            },
            onerror: (error) => {
              console.error('‚ùå Web TTS error:', error);
              isPlaying = false;
              updateTtsControlsInMenu();
              showTTSError(`Web TTS failed: ${error}`);
            }
          };
          
          // Use a high-quality voice
          window.responsiveVoice.speak(text, "US English Female", voiceSettings);
          return true;
        } catch (error) {
          console.error('Web TTS speak error:', error);
          showTTSError(`Web TTS error: ${error.message}`);
          return false;
        }
      }

      // Stop web TTS
      function stopWebTTS() {
        if (webTTSEnabled && window.responsiveVoice) {
          window.responsiveVoice.cancel();
          isPlaying = false;
          updateTtsControlsInMenu();
        }
      }

      // Pause/Resume web TTS
      function pauseResumeWebTTS() {
        if (!webTTSEnabled || !window.responsiveVoice) {
          return false;
        }
        
        if (window.responsiveVoice.isPlaying()) {
          window.responsiveVoice.pause();
          console.log('Web TTS paused');
        } else {
          window.responsiveVoice.resume();
          console.log('Web TTS resumed');
        }
        updateTtsControlsInMenu();
        return true;
      }

      // Force voice loading with retries and system detection
      function forceVoiceLoading() {
        return new Promise((resolve) => {
          console.log(`Voice loading attempt ${voiceLoadingAttempts + 1}/${maxVoiceLoadingAttempts}`);
          
          const voices = speechSynthesis.getVoices();
          if (voices.length > 0) {
            console.log('‚úÖ Voices loaded successfully:', voices.length);
            voicesLoaded = true;
            clearInterval(voiceLoadingInterval);
            resolve(voices);
            return;
          }
          
          voiceLoadingAttempts++;
          
          if (voiceLoadingAttempts >= maxVoiceLoadingAttempts) {
            console.warn('‚ùå Failed to load voices after maximum attempts');
            clearInterval(voiceLoadingInterval);
            
            // Provide system-specific guidance
            const userAgent = navigator.userAgent.toLowerCase();
            let systemGuidance = '';
            
            if (userAgent.includes('linux')) {
              systemGuidance = `
                <strong>Linux System Detected:</strong><br>
                Install TTS packages: <code>sudo apt install espeak espeak-data</code><br>
                Or for better voices: <code>sudo apt install festival festvox-kallpc16k</code><br>
                Then restart your browser.
              `;
            } else if (userAgent.includes('mac')) {
              systemGuidance = `
                <strong>macOS System Detected:</strong><br>
                1. Go to System Preferences ‚Üí Accessibility ‚Üí Speech<br>
                2. Enable "Speak selected text when the key is pressed"<br>
                3. Download additional voices in System Voice settings<br>
                4. Restart your browser.
              `;
            } else if (userAgent.includes('win')) {
              systemGuidance = `
                <strong>Windows System Detected:</strong><br>
                1. Go to Settings ‚Üí Time & Language ‚Üí Speech<br>
                2. Download additional voices<br>
                3. Or install Microsoft Speech Platform Runtime<br>
                4. Restart your browser.
              `;
            } else {
              systemGuidance = `
                <strong>System-specific TTS setup required:</strong><br>
                Your operating system may need TTS voices installed.<br>
                Check your system's accessibility or speech settings.
              `;
            }
            
            showTTSError(`No speech voices found on your system. ${systemGuidance}`);
            resolve([]);
            return;
          }
          
          // Try different methods to trigger voice loading
          if (voiceLoadingAttempts === 1) {
            // Method 1: Create and cancel a dummy utterance
            const dummy = new SpeechSynthesisUtterance('');
            speechSynthesis.speak(dummy);
            speechSynthesis.cancel();
          } else if (voiceLoadingAttempts === 2) {
            // Method 2: Try to access voices multiple times
            for (let i = 0; i < 5; i++) {
              speechSynthesis.getVoices();
            }
          } else if (voiceLoadingAttempts === 3) {
            // Method 3: Try with a longer dummy utterance
            const dummy = new SpeechSynthesisUtterance('test voice loading');
            dummy.volume = 0;
            speechSynthesis.speak(dummy);
            speechSynthesis.cancel();
          }
          
          // Continue trying
          setTimeout(() => forceVoiceLoading().then(resolve), 300);
        });
      }

      // Load available voices with robust error handling
      function loadVoices() {
        availableVoices = speechSynthesis.getVoices();
        console.log('Available voices:', availableVoices.length);
        
        if (voiceSelector) {
          if (availableVoices.length > 0) {
            voiceSelector.innerHTML = '<option value="">Default Voice</option>';
            availableVoices.forEach((voice, index) => {
              const option = document.createElement('option');
              option.value = index;
              option.textContent = `${voice.name} (${voice.lang})`;
              if (voice.default) {
                option.selected = true;
                selectedVoice = voice;
              }
              voiceSelector.appendChild(option);
            });
            console.log('Voice selector populated with', availableVoices.length, 'voices');
            hideTTSError();
          } else {
            voiceSelector.innerHTML = '<option value="">Loading voices...</option>';
          }
        }
      }

      // Global Cloud TTS Manager instance
      let cloudTtsManager = null;

      // Initialize TTS functionality using Cloud TTS
      async function initializeTTS() {
        console.log('üåê Initializing Cloud TTS for PDF viewer...');
        
        try {
          // Wait for CloudTtsManager to be available
          let attempts = 0;
          while (!window.CloudTtsManager && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
          }
          
          if (!window.CloudTtsManager) {
            throw new Error('CloudTtsManager not loaded');
          }
          
          // Initialize Cloud TTS Manager
          cloudTtsManager = new window.CloudTtsManager();
          
          // Set up event handlers
          cloudTtsManager.onSuccess = (message) => {
            console.log('‚úÖ Cloud TTS Ready:', message);
            showTTSSuccess(message);
            loadCloudVoices();
            voicesLoaded = true;
          };

          cloudTtsManager.onError = (guidance) => {
            console.log('‚ÑπÔ∏è Cloud TTS Guidance:', guidance);
            showTTSError(guidance.title + ': ' + guidance.message.replace(/<[^>]*>/g, ''));
          };

          cloudTtsManager.onStatusChange = (status) => {
            isPlaying = status.isPlaying;
            updateTtsControlsInMenu();
          };

          cloudTtsManager.onEnd = () => {
            console.log('üîö TTS ended - checking auto-advance...');
            // Auto-advance to next page if enabled
            if (autoAdvance && currentPageNum < totalPages) {
              console.log(`üìñ Auto-advancing from page ${currentPageNum} to ${currentPageNum + 1}`);
              setTimeout(async () => {
                await renderPage(currentPageNum + 1);
                currentPageText = ''; // Reset text for new page
                if (currentReadingMode === 'audio' || currentReadingMode === 'video') {
                  console.log('üîä Auto-starting TTS on new page');
                  startTTS();
                }
              }, 1000);
            } else {
              console.log('‚èπÔ∏è Auto-advance disabled or on last page');
            }
          };

          // Initialize the cloud TTS system
          const success = await cloudTtsManager.initialize();
          
          if (success) {
            console.log('üéâ Cloud TTS initialization successful');
          } else {
            console.log('‚ÑπÔ∏è Cloud TTS initialized with fallback mode');
          }
          
          // Load preferences from localStorage
          loadPreferences();
          
        } catch (error) {
          console.error('‚ùå Cloud TTS initialization failed:', error);
          showTTSError('Failed to initialize text-to-speech. Using fallback mode.');
          
          // Fallback to old system if cloud TTS fails
          await initializeSystemTTSFallback();
        }
      }

      // Load voices from Cloud TTS Manager
      function loadCloudVoices() {
        if (!cloudTtsManager || !voiceSelector) return;
        
        const voices = cloudTtsManager.getVoices();
        console.log('üé§ Loading cloud voices:', voices.length);
        
        voiceSelector.innerHTML = '<option value="">Default Voice</option>';
        voices.forEach((voice, index) => {
          const option = document.createElement('option');
          option.value = voice.name;
          option.textContent = `${voice.name} (${voice.lang})`;
          voiceSelector.appendChild(option);
        });
        
        console.log('Voice selector populated with', voices.length, 'cloud voices');
      }

      // Fallback to system TTS if cloud TTS fails
      async function initializeSystemTTSFallback() {
        console.log('üîÑ Falling back to system TTS...');
        
        if (window.speechSynthesis) {
          speechSynthesis.addEventListener('voiceschanged', () => {
            console.log('Voices changed event fired');
            loadVoices();
            if (!voicesLoaded && speechSynthesis.getVoices().length > 0) {
              voicesLoaded = true;
              testTTS();
            }
          });
          
          loadVoices();
          
          if (availableVoices.length === 0) {
            console.log('No system voices available, attempting force loading...');
            const voices = await forceVoiceLoading();
            if (voices.length > 0) {
              loadVoices();
              setTimeout(() => testTTS(), 500);
            }
          } else {
            voicesLoaded = true;
            setTimeout(() => testTTS(), 500);
          }
        }
        
        loadPreferences();
      }

      // Extract text from current PDF page
      async function extractPageText(pageNum) {
        if (!currentPdfDoc) return '';
        
        try {
          const page = await currentPdfDoc.getPage(pageNum);
          const textContent = await page.getTextContent();
          const textItems = textContent.items.map(item => item.str);
          return textItems.join(' ').replace(/\s+/g, ' ').trim();
        } catch (error) {
          console.error('Error extracting text from page:', error);
          return '';
        }
      }

      // Update TTS controls in menu
      function updateTtsControlsInMenu() {
        if (!ttsPlayPauseBtn) return;
        
        const isCurrentlyPlaying = speechSynthesis.speaking && !speechSynthesis.paused;
        const isPaused = speechSynthesis.paused;
        
        if (isCurrentlyPlaying) {
          ttsPlayPauseBtn.innerHTML = '<span class="icon">‚è∏Ô∏è</span><span class="text">Pause</span>';
        } else if (isPaused) {
          ttsPlayPauseBtn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span><span class="text">Resume</span>';
        } else {
          ttsPlayPauseBtn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span><span class="text">Play</span>';
        }
      }

      // Start TTS for current page using Cloud TTS
      async function startTTS() {
        console.log('üîä Starting Cloud TTS for current page...');
        console.log('currentPageText:', currentPageText);
        console.log('currentPageNum:', currentPageNum);
        console.log('currentPdfDoc:', !!currentPdfDoc);
        
        // Check if Cloud TTS is available
        if (!cloudTtsManager) {
          console.error('Cloud TTS Manager not initialized');
          showTTSError('Text-to-speech is not initialized. Please refresh the page and try again.');
          return;
        }
        
        if (!currentPageText) {
          console.log('Extracting text from page', currentPageNum);
          currentPageText = await extractPageText(currentPageNum);
          console.log('Extracted text:', currentPageText ? currentPageText.substring(0, 100) + '...' : 'null');
        }
        
        if (!currentPageText) {
          console.warn('No text found on current page');
          showTTSError('No text found on this page to read aloud.');
          return;
        }

        try {
          // Get selected voice and speed from UI
          const selectedVoiceName = voiceSelector ? voiceSelector.value : '';
          const selectedSpeed = speedSelector ? parseFloat(speedSelector.value) : 1.0;
          
          console.log(`üîä Speaking with Cloud TTS: voice="${selectedVoiceName}", speed=${selectedSpeed}`);
          
          // Use Cloud TTS Manager to speak
          await cloudTtsManager.speak(currentPageText, {
            voice: selectedVoiceName || null,
            rate: selectedSpeed,
            lang: 'en'
          });
          
          console.log('‚úÖ Cloud TTS started successfully');
          hideTTSError();
          
        } catch (error) {
          console.error('‚ùå Cloud TTS failed:', error);
          showTTSError(`Text-to-speech failed: ${error.message}`);
          
          // Try fallback to system TTS
          console.log('üîÑ Attempting system TTS fallback...');
          await startSystemTTSFallback();
        }
      }

      // Add system TTS fallback function
      async function startSystemTTSFallback() {
        if (!window.speechSynthesis) {
          throw new Error('System TTS not available');
        }
        
        console.log('üîÑ Using system TTS fallback...');
        
        // Stop any existing speech
        speechSynthesis.cancel();
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const utterance = new SpeechSynthesisUtterance(currentPageText);
        utterance.rate = speechRate;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        utterance.onstart = () => {
          console.log('‚úÖ System TTS started');
          isPlaying = true;
          updateTtsControlsInMenu();
          hideTTSError();
        };
        
        utterance.onend = () => {
          console.log('System TTS ended');
          isPlaying = false;
          updateTtsControlsInMenu();
          
          // Auto-advance if enabled
          if (autoAdvance && currentPageNum < totalPages) {
            setTimeout(async () => {
              await renderPage(currentPageNum + 1);
              currentPageText = '';
              if (currentReadingMode === 'audio' || currentReadingMode === 'video') {
                startTTS();
              }
            }, 1000);
          }
        };
        
        utterance.onerror = (event) => {
          console.error('‚ùå System TTS error:', event.error);
          isPlaying = false;
          updateTtsControlsInMenu();
          showTTSError(`System TTS failed: ${event.error}`);
        };
        
        speechSynthesis.speak(utterance);
      }

      // Stop TTS (handles cloud and system TTS)
      function stopTTS() {
        console.log('‚èπÔ∏è Stopping TTS...');
        
        if (cloudTtsManager) {
          cloudTtsManager.stop();
        }
        
        // Also stop system TTS as fallback
        if (window.speechSynthesis) {
          speechSynthesis.cancel();
        }
        
        isPlaying = false;
        updateTtsControlsInMenu();
        console.log('TTS stopped');
      }

      // Pause/Resume TTS (handles cloud and system TTS)
      function pauseResumeTTS() {
        console.log('‚è∏Ô∏è‚ñ∂Ô∏è Pause/Resume TTS...');
        
        if (cloudTtsManager) {
          if (isPlaying) {
            cloudTtsManager.pause();
            console.log('Cloud TTS paused');
          } else {
            // If not playing, start TTS
            startTTS();
          }
        } else if (window.speechSynthesis) {
          // Fallback to system TTS
          if (speechSynthesis.speaking && !speechSynthesis.paused) {
            speechSynthesis.pause();
            console.log('System TTS paused');
          } else if (speechSynthesis.paused) {
            speechSynthesis.resume();
            console.log('System TTS resumed');
          } else {
            startTTS();
          }
        }
        
        updateTtsControlsInMenu();
      }

      // Update reading mode
      function updateReadingMode(mode) {
        console.log('updateReadingMode called with mode:', mode);
        currentReadingMode = mode;
        
        // Show/hide TTS controls section
        if (ttsMenuSection) {
          const shouldShow = mode !== 'read';
          ttsMenuSection.style.display = shouldShow ? 'block' : 'none';
          console.log('TTS section display set to:', shouldShow ? 'block' : 'none');
        } else {
          console.error('ttsMenuSection not found!');
        }
        
        // Stop TTS if switching to read-only mode
        if (mode === 'read') {
          console.log('Stopping TTS for read mode');
          stopTTS();
        }
        
        // For audio/video modes, just prepare but don't auto-start
        if (mode === 'audio' || mode === 'video') {
          console.log(`Switched to ${mode} mode - ready for TTS (click Play to start)`);
          currentPageText = ''; // Reset to extract fresh text when user clicks play
          // Don't auto-start - wait for user to click play button
        }
        
        savePreferences();
      }

      // Menu toggle functionality
      function toggleMenu() {
        // Debounce to prevent rapid double-clicks
        const now = Date.now();
        if (now - lastToggleTime < 300) { // 300ms debounce
          console.log('Toggle ignored due to debounce');
          return;
        }
        lastToggleTime = now;
        
        console.log('toggleMenu called, menuOverlay:', menuOverlay);
        if (!menuOverlay) {
          console.error('menuOverlay not found!');
          // Try to find it again
          menuOverlay = document.getElementById('pdf-menu-overlay');
          console.log('Retry finding menuOverlay:', menuOverlay);
          if (!menuOverlay) return;
        }
        
        const isVisible = menuOverlay.classList.contains('show');
        console.log('Menu currently visible:', isVisible);
        
        if (isVisible) {
          closeMenu();
        } else {
          openMenu();
        }
      }

      // Open menu function
      function openMenu() {
        console.log('openMenu() called');
        if (!menuOverlay) {
          console.error('menuOverlay not found in openMenu');
          return;
        }
        
        // Show the overlay
        menuOverlay.classList.add('show');
        console.log('Added show class to overlay');
        
        // Add animation class for smooth entrance
        setTimeout(() => {
          if (menuModal) {
            menuModal.classList.add('menu-modal-open');
            console.log('Added animation class to modal');
          }
        }, 10);
        
        // Prevent body scrolling when modal is open
        document.body.style.overflow = 'hidden';
        
        console.log('Menu opened successfully, overlay classes:', menuOverlay.className);
      }

      // Close menu function
      function closeMenu() {
        console.log('closeMenu() called');
        if (!menuOverlay) {
          console.error('menuOverlay not found in closeMenu');
          return;
        }
        
        console.log('Menu was open, closing...');
        
        // Remove animation class
        if (menuModal) {
          menuModal.classList.remove('menu-modal-open');
        }
        
        // Hide overlay after animation
        setTimeout(() => {
          menuOverlay.classList.remove('show');
          // Restore body scrolling
          document.body.style.overflow = '';
          console.log('Menu closed, overlay classes:', menuOverlay.className);
        }, 200);
        
        console.log('Menu close initiated');
      }


      // Save preferences to localStorage
      function savePreferences() {
        const preferences = {
          readingMode: currentReadingMode,
          voice: voiceSelector ? voiceSelector.value : '',
          speed: speechRate,
          autoAdvance: autoAdvance,
          highlightColor: highlightColor,
          darkMode: darkMode
        };
        
        localStorage.setItem('pdfViewerPreferences', JSON.stringify(preferences));
      }

      // Load preferences from localStorage
      function loadPreferences() {
        try {
          const saved = localStorage.getItem('pdfViewerPreferences');
          if (saved) {
            const preferences = JSON.parse(saved);
            
            // Apply reading mode
            if (preferences.readingMode) {
              currentReadingMode = preferences.readingMode;
              const modeInput = document.querySelector(`input[value="${preferences.readingMode}"]`);
              if (modeInput) {
                modeInput.checked = true;
                updateReadingMode(preferences.readingMode);
              }
            }
            
            // Apply voice selection
            if (preferences.voice && voiceSelector) {
              voiceSelector.value = preferences.voice;
              if (preferences.voice && availableVoices[preferences.voice]) {
                selectedVoice = availableVoices[preferences.voice];
              }
            }
            
            // Apply speed
            if (preferences.speed && speedSelector) {
              speechRate = preferences.speed;
              speedSelector.value = preferences.speed;
            }
            
            // Apply auto-advance
            if (preferences.autoAdvance !== undefined && autoAdvanceCheckbox) {
              autoAdvance = preferences.autoAdvance;
              autoAdvanceCheckbox.checked = preferences.autoAdvance;
            }
            
            // Apply highlight color
            if (preferences.highlightColor && highlightColorInput) {
              highlightColor = preferences.highlightColor;
              highlightColorInput.value = preferences.highlightColor;
            }
            
            // Apply dark mode
            if (preferences.darkMode !== undefined && darkModeCheckbox) {
              darkMode = preferences.darkMode;
              darkModeCheckbox.checked = preferences.darkMode;
              applyDarkMode(preferences.darkMode);
            }
          }
        } catch (error) {
          console.error('Error loading preferences:', error);
        }
      }

      // Apply dark mode
      function applyDarkMode(enabled) {
        const container = document.getElementById('pdf-viewer-container');
        if (container) {
          if (enabled) {
            container.classList.add('dark-mode');
          } else {
            container.classList.remove('dark-mode');
          }
        }
      }

      // Function to set up all menu event listeners
      function setupMenuEventListeners() {
        // Event Listeners for Menu
        if (menuBtn) {
          // Remove any existing listeners first
          if (menuBtn.hasAttribute('data-menu-listener')) {
            console.log('Menu button already has listener, skipping...');
            return;
          }
          
          console.log('Adding click listener to menu button');
          menuBtn.addEventListener('click', (e) => {
            console.log('Menu button clicked!');
            e.stopPropagation();
            e.preventDefault();
            toggleMenu();
          }, true); // Use capture phase to ensure it runs first
          
          // Mark that listener has been added
          menuBtn.setAttribute('data-menu-listener', 'true');
        } else {
          console.error('Menu button not found!');
        }

        // Close menu when clicking close button
        if (menuCloseBtn) {
          menuCloseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeMenu();
          });
        }

        // Close menu when clicking overlay background
        if (menuOverlay) {
          menuOverlay.addEventListener('click', (e) => {
            console.log('Overlay clicked, target:', e.target, 'overlay:', menuOverlay);
            // Only close if clicking the overlay itself, not the modal content
            if (e.target === menuOverlay) {
              console.log('Closing menu due to overlay background click');
              e.stopPropagation();
              closeMenu();
            }
          });
        }

        // Prevent modal content clicks from closing the menu
        if (menuModal) {
          menuModal.addEventListener('click', (e) => {
            console.log('Modal content clicked, preventing propagation');
            e.stopPropagation();
          });
        }

        // Close menu with Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && menuOverlay && menuOverlay.classList.contains('show')) {
            console.log('Escape key pressed, closing menu');
            closeMenu();
          }
        });

        // Reading mode change handlers
        if (readingModeInputs) {
          readingModeInputs.forEach(input => {
            input.addEventListener('change', (e) => {
              if (e.target.checked) {
                updateReadingMode(e.target.value);
              }
            });
          });
        }

        // TTS control handlers
        if (ttsPlayPauseBtn) {
          console.log('Adding click listener to TTS play/pause button');
          ttsPlayPauseBtn.addEventListener('click', (e) => {
            console.log('TTS play/pause button clicked!');
            e.preventDefault();
            e.stopPropagation();
            pauseResumeTTS();
          });
        } else {
          console.error('TTS play/pause button not found!');
        }

        if (ttsStopBtn) {
          console.log('Adding click listener to TTS stop button');
          ttsStopBtn.addEventListener('click', (e) => {
            console.log('TTS stop button clicked!');
            e.preventDefault();
            e.stopPropagation();
            stopTTS();
          });
        } else {
          console.error('TTS stop button not found!');
        }

        if (voiceSelector) {
          voiceSelector.addEventListener('change', (e) => {
            if (e.target.value && availableVoices[e.target.value]) {
              selectedVoice = availableVoices[e.target.value];
            } else {
              selectedVoice = null;
            }
            savePreferences();
          });
        }

        if (speedSelector) {
          speedSelector.addEventListener('change', (e) => {
            speechRate = parseFloat(e.target.value);
            console.log(`üéõÔ∏è Speed changed to ${speechRate}x`);
            savePreferences();
            
            // If currently playing, try to update speed without restarting
            if (isPlaying && (currentReadingMode === 'audio' || currentReadingMode === 'video')) {
              if (cloudTtsManager && cloudTtsManager.setPlaybackRate) {
                // Try to update playback rate of current audio
                const updated = cloudTtsManager.setPlaybackRate(speechRate);
                if (updated) {
                  console.log('‚úÖ Speed updated during playback');
                } else {
                  // Fallback: restart TTS with new speed
                  console.log('üîÑ Restarting TTS with new speed...');
                  stopTTS();
                  setTimeout(() => {
                    startTTS();
                  }, 500);
                }
              } else {
                // Fallback for system TTS or if cloud TTS doesn't support live updates
                console.log('üîÑ Restarting TTS with new speed...');
                stopTTS();
                setTimeout(() => {
                  startTTS();
                }, 500);
              }
            }
          });
        }

        if (autoAdvanceCheckbox) {
          autoAdvanceCheckbox.addEventListener('change', (e) => {
            autoAdvance = e.target.checked;
            savePreferences();
          });
        }

        if (highlightColorInput) {
          highlightColorInput.addEventListener('change', (e) => {
            highlightColor = e.target.value;
            savePreferences();
          });
        }

        if (darkModeCheckbox) {
          darkModeCheckbox.addEventListener('change', (e) => {
            darkMode = e.target.checked;
            applyDarkMode(darkMode);
            savePreferences();
          });
        }
      }

      // Initialize TTS when PDF is loaded
      initializeTTS();

      // Initialize menu elements and event listeners after PDF is loaded
      initializeMenuElements();

      // Reset page text when page changes (hook into existing render function)
      const originalRenderPage = renderPage;
      renderPage = async function(num, scale = null) {
        currentPageText = ''; // Reset text for new page
        await originalRenderPage(num, scale);
        
        // If in audio/video mode, extract text for new page
        if (currentReadingMode === 'audio' || currentReadingMode === 'video') {
          currentPageText = await extractPageText(num);
        }
      };

    } catch (error) {
      console.error("Error loading or rendering PDF:", error);
      const container = document.getElementById('pdf-viewer-container');
      if (container) {
        container.innerHTML = `<p>Error loading PDF: ${error.message}.</p>`;
      }
    }
  }

  // Initialize immediately
  initializePdfViewer();

  // Reinitialize after view transitions
  document.addEventListener('astro:page-load', () => {
    console.log('Page loaded, reinitializing PDF viewer');
    initializePdfViewer();
  });

  // Also reinitialize on beforeunload to ensure cleanup
  window.addEventListener('beforeunload', () => {
    cleanupPdfViewer();
  });
</script>

<style>
  .pdf-viewer-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 1px solid #ccc;
    background-color: #f9f9f9;
    padding: 10px;
    box-sizing: border-box;
    /* Ensure it respects the parent's height constraints */
    height: 100%; 
    overflow: hidden; /* Hide canvas overflow if any */
  }

  #pdf-canvas {
    border: 1px solid #bbb;
    /* max-width: 100%; */ /* Let canvas size be determined by PDF.js viewport */
    /* Height will be set by PDF.js based on page dimensions and scale */
    /* We'll make the canvas scrollable if it's taller than its container */
    display: block; /* Remove extra space below canvas */
    margin-bottom: 10px;
    flex-shrink: 0; /* Prevent canvas from shrinking within its flex parent (.canvas-wrapper) */
    /* Ensure proper orientation and prevent flipping */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
  }
  
  /* Make the canvas container scrollable if PDF page is tall */
  .pdf-viewer-container > #pdf-canvas {
      overflow-y: auto; /* This won't work directly on canvas, need a wrapper or adjust container */
      /* For now, let's assume the main container will handle scrolling if needed,
         or the canvas itself will be sized to fit.
         A better approach for tall pages is to put canvas in a scrollable div.
         Let's adjust the container to be scrollable for the canvas.
      */
  }

  /* Let's create a dedicated scrollable area for the canvas */
  .canvas-wrapper {
    width: 100%;
    flex-grow: 1; /* Takes up available vertical space */
    overflow-y: auto; /* Allows scrolling for tall PDF pages */
    overflow-x: auto; /* Allows scrolling for wide PDF pages (zoomed in) */
    display: flex;
    justify-content: center; /* Center canvas if it's narrower than wrapper */
    margin-bottom: 10px;
  }


  .pdf-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px 0;
    background-color: #eee;
    width: 100%;
    box-sizing: border-box;
    flex-shrink: 0; /* Prevent controls from shrinking */
  }

  .pdf-controls button {
    padding: 8px 12px;
    margin: 0 10px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  .pdf-controls button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
  }

  .pdf-controls span {
    margin: 0 5px;
    font-size: 1em;
  }
  .page-indicator {
    cursor: pointer;
    padding: 0 5px; /* Give some clickable area */
    display: inline-flex; /* To align text nicely */
    align-items: center;
  }
  /* .page-input-container is now a child of page-navigation-group */
  .page-input-container {
    display: flex;
    align-items: center;
    justify-content: center; /* Center input and button if group is wider */
    /* margin: 0 5px; /* Margin now on page-navigation-group or individual elements */
  }
  /* .page-input-error-message class removed */
  #page-input {
    width: 50px; /* Slightly wider for 3 digits */
    text-align: right;
    margin-right: 5px;
    padding: 4px 6px; /* Increased padding for better touch */
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 0.95em;
  }
  #page-input.input-error {
    border-color: #d9534f; /* Red border for error */
    box-shadow: 0 0 0 0.2rem rgba(217, 83, 79, 0.25); /* Optional: subtle glow */
  }
  .page-input-error-icon {
    color: #d9534f; /* Red color for the icon */
    margin-left: 5px;
    cursor: help; /* Indicates more info on hover */
    font-weight: bold;
    display: inline-flex; /* To align with button/input */
    align-items: center;
  }
  #goto-page-btn {
    padding: 5px 10px; /* Increased padding */
    font-size: 0.9em;
    /* background-color: #007bff; Already default button style */
    /* color: white; Already default button style */
    /* border: none; Already default button style */
    /* border-radius: 3px; Already default button style */
    /* cursor: pointer; Already default button style */
    line-height: 1; /* Ensure text is centered well */
  }

  .spacer {
    margin: 0 10px; /* Adds some space */
  }

  .pdf-controls button .icon {
    display: none; /* Hidden by default, shown on mobile for prev/next */
    font-weight: bold; /* Make icons bold by default if they are shown */
  }
  .pdf-controls button .text {
    display: inline; /* Shown by default, hidden on mobile for specified buttons */
  }

  /* Fullscreen button icon always visible */
  .pdf-controls button#fullscreen-btn .icon {
    display: inline;
    font-size: 1.2em; /* Make icon a bit larger */
  }
   /* Fullscreen button text always hidden (already set inline, but good for clarity) */
  .pdf-controls button#fullscreen-btn .text {
    display: none !important;
  }


  /* Mobile styles */
  @media (max-width: 768px) {
    .pdf-controls button#prev-page .text,
    .pdf-controls button#next-page .text { /* Fullscreen text already handled */
      display: none;
    }

    .pdf-controls button#prev-page .icon,
    .pdf-controls button#next-page .icon { /* Fullscreen icon already handled */
      display: inline;
    }
    
    /* Zoom buttons on mobile */
    .pdf-controls button.zoom-button {
      font-weight: bold;
      padding: 8px; /* Make it more square-like and consistent with other mobile icon buttons */
    }

    .zoom-level-display {
      display: none; /* Hide zoom percentage on mobile */
    }

    .pdf-controls button {
      padding: 8px; /* Default padding for icon buttons on mobile */
      margin: 0 5px;
    }
     /* Ensure fullscreen icon button has consistent padding on mobile */
    .pdf-controls button#fullscreen-btn {
        padding: 8px 10px;
    }

    /* Hamburger menu button on mobile */
    .menu-button {
      padding: 8px 10px !important;
    }

    /* Mobile menu dropdown adjustments */
    .pdf-menu-dropdown {
      position: fixed !important;
      left: 10px !important;
      right: 10px !important;
      top: auto !important;
      bottom: 10px !important;
      width: auto !important;
      min-width: auto !important;
      max-width: none !important;
      max-height: 60vh !important;
    }

    .menu-section {
      padding: 10px 12px;
    }

    .control-row {
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
    }

    .control-label {
      min-width: auto;
      margin-bottom: 2px;
    }
  }

  /* NEW: Hamburger Menu Button Styles */
  .menu-button {
    padding: 8px 12px !important;
    margin: 0 5px !important;
    background-color: #007bff !important;
    color: white !important;
    border: none !important;
    border-radius: 4px !important;
    cursor: pointer !important;
    font-size: 1.2em !important;
  }

  .menu-button:hover {
    background-color: #0056b3 !important;
  }

  .menu-button .icon {
    display: inline !important;
    font-weight: bold !important;
  }

  /* NEW: Modal Overlay Styles */
  .pdf-menu-overlay {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    background: rgba(0, 0, 0, 0.5) !important;
    z-index: 10000 !important;
    display: none !important; /* Hidden by default */
    align-items: center !important;
    justify-content: center !important;
    backdrop-filter: blur(2px) !important;
  }

  .pdf-menu-overlay.show {
    display: flex !important; /* Show when .show class is added */
  }

  .pdf-menu-modal {
    background: white !important;
    border-radius: 12px !important;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3) !important;
    max-width: 90vw !important;
    max-height: 90vh !important;
    width: 400px !important;
    overflow: hidden !important;
    transform: scale(0.9) !important;
    opacity: 0 !important;
    transition: all 0.2s ease !important;
  }

  .pdf-menu-modal.menu-modal-open {
    transform: scale(1) !important;
    opacity: 1 !important;
  }

  .menu-header {
    background: #007bff !important;
    color: white !important;
    padding: 16px 20px !important;
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    border-bottom: 1px solid #e9ecef !important;
  }

  .menu-title {
    margin: 0 !important;
    font-size: 1.1em !important;
    font-weight: 600 !important;
  }

  .menu-close-btn {
    background: none !important;
    border: none !important;
    color: white !important;
    font-size: 24px !important;
    cursor: pointer !important;
    padding: 0 !important;
    width: 30px !important;
    height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    border-radius: 50% !important;
    transition: background-color 0.2s ease !important;
  }

  .menu-close-btn:hover {
    background: rgba(255, 255, 255, 0.2) !important;
  }

  .menu-content {
    max-height: 70vh !important;
    overflow-y: auto !important;
    padding: 0 !important;
  }

  .menu-section {
    padding: 16px 20px !important;
    border-bottom: 1px solid #e9ecef !important;
  }

  .menu-section:last-child {
    border-bottom: none !important;
  }

  .menu-section-title {
    margin: 0 0 12px 0 !important;
    font-size: 0.95em !important;
    font-weight: 600 !important;
    color: #333 !important;
    text-transform: uppercase !important;
    letter-spacing: 0.5px !important;
  }

  .menu-options {
    display: flex !important;
    flex-direction: column !important;
    gap: 8px !important;
  }

  .menu-option {
    display: flex !important;
    align-items: center !important;
    gap: 10px !important;
    cursor: pointer !important;
    padding: 8px 10px !important;
    border-radius: 6px !important;
    transition: background-color 0.2s ease !important;
  }

  .menu-option:hover {
    background-color: #f8f9fa !important;
  }

  .menu-option input[type="radio"],
  .menu-option input[type="checkbox"] {
    margin: 0 !important;
    cursor: pointer !important;
  }

  .option-icon {
    font-size: 1.2em !important;
    width: 24px !important;
    text-align: center !important;
  }

  .option-text {
    font-size: 0.95em !important;
    color: #333 !important;
    flex-grow: 1 !important;
  }

  .menu-controls {
    display: flex !important;
    flex-direction: column !important;
    gap: 10px !important;
  }

  .control-row {
    display: flex !important;
    align-items: center !important;
    gap: 10px !important;
    flex-wrap: wrap !important;
  }

  .control-label {
    font-size: 0.9em !important;
    color: #555 !important;
    min-width: 70px !important;
    font-weight: 500 !important;
  }

  .menu-control-btn {
    padding: 8px 14px !important;
    margin: 0 6px 0 0 !important;
    background-color: #28a745 !important;
    color: white !important;
    border: none !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-size: 0.9em !important;
    display: flex !important;
    align-items: center !important;
    gap: 6px !important;
    transition: background-color 0.2s ease !important;
  }

  .menu-control-btn:hover {
    background-color: #218838 !important;
  }

  .menu-control-btn .icon {
    font-size: 1em !important;
  }

  .menu-control-btn .text {
    font-size: 0.9em !important;
  }

  .menu-select {
    padding: 6px 10px !important;
    border: 1px solid #ccc !important;
    border-radius: 6px !important;
    font-size: 0.9em !important;
    background: white !important;
    cursor: pointer !important;
    flex-grow: 1 !important;
    min-width: 120px !important;
  }

  .menu-select:focus {
    outline: none !important;
    border-color: #007bff !important;
    box-shadow: 0 0 0 2px rgba(0,123,255,0.25) !important;
  }

  .color-picker {
    width: 44px !important;
    height: 32px !important;
    border: 1px solid #ccc !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    background: none !important;
    padding: 0 !important;
  }

  .color-picker::-webkit-color-swatch-wrapper {
    padding: 0 !important;
  }

  .color-picker::-webkit-color-swatch {
    border: none !important;
    border-radius: 4px !important;
  }

  /* Dark Mode Styles */
  .pdf-viewer-container.dark-mode {
    background-color: #2d3748;
    color: #e2e8f0;
    border-color: #4a5568;
  }

  .pdf-viewer-container.dark-mode .pdf-controls {
    background-color: #4a5568;
  }

  .pdf-viewer-container.dark-mode #pdf-canvas {
    border-color: #718096;
  }

  .dark-mode .pdf-menu-modal {
    background: #2d3748 !important;
    color: #e2e8f0 !important;
  }

  .dark-mode .menu-header {
    background: #4a5568 !important;
    border-bottom-color: #718096 !important;
  }

  .dark-mode .menu-section {
    border-bottom-color: #4a5568 !important;
  }

  .dark-mode .menu-section-title {
    color: #e2e8f0 !important;
  }

  .dark-mode .option-text {
    color: #e2e8f0 !important;
  }

  .dark-mode .control-label {
    color: #cbd5e0 !important;
  }

  .dark-mode .menu-option:hover {
    background-color: #4a5568 !important;
  }

  .dark-mode .menu-select {
    background: #4a5568 !important;
    border-color: #718096 !important;
    color: #e2e8f0 !important;
  }
</style>